var N = null;var searchIndex = {};
searchIndex["num"]={"doc":"A collection of numeric types and traits for Rust.","items":[[3,"BigInt","num","A big signed integer type.",N,N],[3,"BigUint","","A big unsigned integer type.",N,N],[3,"Complex","","A complex number in Cartesian form.",N,N],[12,"re","","Real portion of the complex number",0,N],[12,"im","","Imaginary portion of the complex number",0,N],[6,"Rational","","Alias for a `Ratio` of machine-sized integers.",N,N],[6,"BigRational","","Alias for arbitrary precision rationals.",N,N],[8,"Integer","","",N,N],[10,"div_floor","","Floored integer division.",1,[[["self"],["self"]],["self"]]],[10,"mod_floor","","Floored integer modulo, satisfying:",1,[[["self"],["self"]],["self"]]],[10,"gcd","","Greatest Common Divisor (GCD).",1,[[["self"],["self"]],["self"]]],[10,"lcm","","Lowest Common Multiple (LCM).",1,[[["self"],["self"]],["self"]]],[10,"divides","","Deprecated, use `is_multiple_of` instead.",1,[[["self"],["self"]],["bool"]]],[10,"is_multiple_of","","Returns `true` if `self` is a multiple of `other`.",1,[[["self"],["self"]],["bool"]]],[10,"is_even","","Returns `true` if the number is even.",1,[[["self"]],["bool"]]],[10,"is_odd","","Returns `true` if the number is odd.",1,[[["self"]],["bool"]]],[10,"div_rem","","Simultaneous truncated integer division and modulus. Returns `(quotient, remainder)`.",1,N],[11,"div_mod_floor","","Simultaneous floored integer division and modulus. Returns `(quotient, remainder)`.",1,N],[5,"range","","Returns an iterator over the given range [start, stop) (that is, starting at start (inclusive), and ending at stop (exclusive)).",N,[[["a"],["a"]],["range"]]],[5,"range_inclusive","","Return an iterator over the range [start, stop]",N,[[["a"],["a"]],["rangeinclusive"]]],[5,"range_step","","Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.",N,[[["a"],["a"],["a"]],["rangestep"]]],[5,"range_step_inclusive","","Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.",N,[[["a"],["a"],["a"]],["rangestepinclusive"]]],[8,"Num","","The base trait for numeric types, covering `0` and `1` values, comparisons, basic numeric operations, and string conversion.",N,N],[16,"FromStrRadixErr","","",2,N],[10,"from_str_radix","","Convert from a string and radix <= 36.",2,[[["str"],["u32"]],["result"]]],[8,"Zero","","Defines an additive identity element for `Self`.",N,N],[10,"zero","","Returns the additive identity element of `Self`, `0`.",3,[[],["self"]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",3,[[["self"]],["bool"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",N,N],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",4,[[],["self"]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative identity.",4,[[["self"]],["bool"]]],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can be negative).",N,N],[10,"abs","","Computes the absolute value.",5,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",5,[[["self"],["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",5,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",5,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",5,[[["self"]],["bool"]]],[8,"Unsigned","","A trait for values which cannot be negative",N,N],[8,"Bounded","","Numbers which have upper and lower bounds",N,N],[10,"min_value","","returns the smallest finite number this type can represent",6,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",6,[[],["self"]]],[5,"one","","Returns the multiplicative identity, `1`.",N,[[],["t"]]],[5,"zero","","Returns the additive identity, `0`.",N,[[],["t"]]],[5,"abs","","Computes the absolute value.",N,[[["t"]],["t"]]],[5,"abs_sub","","The positive difference of two numbers.",N,[[["t"],["t"]],["t"]]],[5,"signum","","Returns the sign of the number.",N,[[["t"]],["t"]]],[8,"Saturating","","Saturating math operations",N,N],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at the numeric bounds instead of overflowing.",7,[[["self"],["self"]],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating at the numeric bounds instead of overflowing.",7,[[["self"],["self"]],["self"]]],[8,"CheckedAdd","","Performs addition that returns `None` instead of wrapping around on overflow.",N,N],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow happens, `None` is returned.",8,[[["self"],["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of wrapping around on underflow.",N,N],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.",9,[[["self"],["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of wrapping around on underflow or overflow.",N,N],[10,"checked_mul","","Multiplies two numbers, checking for underflow or overflow. If underflow or overflow happens, `None` is returned.",10,[[["self"],["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking on division by zero and instead of wrapping around on underflow and overflow.",N,N],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and division by zero. If any of that happens, `None` is returned.",11,[[["self"],["self"]],["option"]]],[8,"PrimInt","","",N,N],[10,"count_ones","","Returns the number of ones in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount, `n`, wrapping the truncated bits to the end of the resulting integer.",12,[[["self"],["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount, `n`, wrapping the truncated bits to the beginning of the resulting integer.",12,[[["self"],["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",12,[[["self"],["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount, `n`, copying the \"sign bit\" in the most significant bits even for unsigned types.",12,[[["self"],["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",12,[[["self"],["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount, `n`, filling zeros in the most significant bits.",12,[[["self"],["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",12,[[["self"]],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's endianness.",12,[[["self"]],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's endianness.",12,[[["self"]],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",12,[[["self"]],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's endianness.",12,[[["self"]],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by squaring.",12,[[["self"],["u32"]],["self"]]],[8,"ToPrimitive","","A generic trait for converting a value to a number.",N,N],[11,"to_isize","","Converts the value of `self` to an `isize`.",13,[[["self"]],["option",["isize"]]]],[11,"to_i8","","Converts the value of `self` to an `i8`.",13,[[["self"]],["option",["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`.",13,[[["self"]],["option",["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`.",13,[[["self"]],["option",["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`.",13,[[["self"]],["option",["i64"]]]],[11,"to_i128","","Converts the value of `self` to an `i128`.",13,[[["self"]],["option",["i128"]]]],[11,"to_usize","","Converts the value of `self` to a `usize`.",13,[[["self"]],["option",["usize"]]]],[11,"to_u8","","Converts the value of `self` to an `u8`.",13,[[["self"]],["option",["u8"]]]],[11,"to_u16","","Converts the value of `self` to an `u16`.",13,[[["self"]],["option",["u16"]]]],[11,"to_u32","","Converts the value of `self` to an `u32`.",13,[[["self"]],["option",["u32"]]]],[10,"to_u64","","Converts the value of `self` to an `u64`.",13,[[["self"]],["option",["u64"]]]],[11,"to_u128","","Converts the value of `self` to an `u128`.",13,[[["self"]],["option",["u128"]]]],[11,"to_f32","","Converts the value of `self` to an `f32`.",13,[[["self"]],["option",["f32"]]]],[11,"to_f64","","Converts the value of `self` to an `f64`.",13,[[["self"]],["option",["f64"]]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",N,N],[11,"from_isize","","Convert an `isize` to return an optional value of this type. If the value cannot be represented by this value, then `None` is returned.",14,[[["isize"]],["option"]]],[11,"from_i8","","Convert an `i8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i8"]],["option"]]],[11,"from_i16","","Convert an `i16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i16"]],["option"]]],[11,"from_i32","","Convert an `i32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i32"]],["option"]]],[10,"from_i64","","Convert an `i64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i64"]],["option"]]],[11,"from_i128","","Convert an `i128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i128"]],["option"]]],[11,"from_usize","","Convert a `usize` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["usize"]],["option"]]],[11,"from_u8","","Convert an `u8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u8"]],["option"]]],[11,"from_u16","","Convert an `u16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u16"]],["option"]]],[11,"from_u32","","Convert an `u32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u32"]],["option"]]],[10,"from_u64","","Convert an `u64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u64"]],["option"]]],[11,"from_u128","","Convert an `u128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u128"]],["option"]]],[11,"from_f32","","Convert a `f32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["f32"]],["option"]]],[11,"from_f64","","Convert a `f64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["f64"]],["option"]]],[8,"NumCast","","An interface for casting between machine scalars.",N,N],[10,"from","","Creates a number from another value that can be converted into a primitive via the `ToPrimitive` trait.",15,[[["t"]],["option"]]],[0,"cast","","",N,N],[8,"ToPrimitive","num::cast","A generic trait for converting a value to a number.",N,N],[11,"to_isize","","Converts the value of `self` to an `isize`.",13,[[["self"]],["option",["isize"]]]],[11,"to_i8","","Converts the value of `self` to an `i8`.",13,[[["self"]],["option",["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`.",13,[[["self"]],["option",["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`.",13,[[["self"]],["option",["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`.",13,[[["self"]],["option",["i64"]]]],[11,"to_i128","","Converts the value of `self` to an `i128`.",13,[[["self"]],["option",["i128"]]]],[11,"to_usize","","Converts the value of `self` to a `usize`.",13,[[["self"]],["option",["usize"]]]],[11,"to_u8","","Converts the value of `self` to an `u8`.",13,[[["self"]],["option",["u8"]]]],[11,"to_u16","","Converts the value of `self` to an `u16`.",13,[[["self"]],["option",["u16"]]]],[11,"to_u32","","Converts the value of `self` to an `u32`.",13,[[["self"]],["option",["u32"]]]],[10,"to_u64","","Converts the value of `self` to an `u64`.",13,[[["self"]],["option",["u64"]]]],[11,"to_u128","","Converts the value of `self` to an `u128`.",13,[[["self"]],["option",["u128"]]]],[11,"to_f32","","Converts the value of `self` to an `f32`.",13,[[["self"]],["option",["f32"]]]],[11,"to_f64","","Converts the value of `self` to an `f64`.",13,[[["self"]],["option",["f64"]]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",N,N],[11,"from_isize","","Convert an `isize` to return an optional value of this type. If the value cannot be represented by this value, then `None` is returned.",14,[[["isize"]],["option"]]],[11,"from_i8","","Convert an `i8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i8"]],["option"]]],[11,"from_i16","","Convert an `i16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i16"]],["option"]]],[11,"from_i32","","Convert an `i32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i32"]],["option"]]],[10,"from_i64","","Convert an `i64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i64"]],["option"]]],[11,"from_i128","","Convert an `i128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i128"]],["option"]]],[11,"from_usize","","Convert a `usize` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["usize"]],["option"]]],[11,"from_u8","","Convert an `u8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u8"]],["option"]]],[11,"from_u16","","Convert an `u16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u16"]],["option"]]],[11,"from_u32","","Convert an `u32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u32"]],["option"]]],[10,"from_u64","","Convert an `u64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u64"]],["option"]]],[11,"from_u128","","Convert an `u128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u128"]],["option"]]],[11,"from_f32","","Convert a `f32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["f32"]],["option"]]],[11,"from_f64","","Convert a `f64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["f64"]],["option"]]],[5,"cast","","Cast from one machine scalar to another.",N,[[["t"]],["option"]]],[8,"NumCast","","An interface for casting between machine scalars.",N,N],[10,"from","","Creates a number from another value that can be converted into a primitive via the `ToPrimitive` trait.",15,[[["t"]],["option"]]],[8,"AsPrimitive","","A generic interface for casting between machine scalars with the `as` operator, which admits narrowing and precision loss. Implementers of this trait AsPrimitive should behave like a primitive numeric type (e.g. a newtype around another primitive), and the intended conversion must never fail.",N,N],[10,"as_","","Convert a value to another, using the `as` operator.",16,[[["self"]],["t"]]],[5,"cast","num","Cast from one machine scalar to another.",N,[[["t"]],["option"]]],[0,"pow","","",N,N],[8,"Pow","num::pow","Binary operator for raising a value to a power.",N,N],[16,"Output","","The result after applying the operator.",17,N],[10,"pow","","Returns `self` to the power `rhs`.",17,N],[5,"pow","","Raises a value to the power of exp, using exponentiation by squaring.",N,[[["t"],["usize"]],["t"]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an overflow occurred.",N,[[["t"],["usize"]],["option"]]],[5,"pow","num","Raises a value to the power of exp, using exponentiation by squaring.",N,[[["t"],["usize"]],["t"]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an overflow occurred.",N,[[["t"],["usize"]],["option"]]],[5,"clamp","","A value bounded by a minimum and a maximum",N,[[["t"],["t"],["t"]],["t"]]],[8,"Float","","Generic trait for floating point numbers",N,N],[10,"nan","","Returns the `NaN` value.",18,[[],["self"]]],[10,"infinity","","Returns the infinite value.",18,[[],["self"]]],[10,"neg_infinity","","Returns the negative infinite value.",18,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",18,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can represent.",18,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",18,[[],["self"]]],[11,"epsilon","","Returns epsilon, a small positive value.",18,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can represent.",18,[[],["self"]]],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",18,[[["self"]],["bool"]]],[10,"is_infinite","","Returns `true` if this value is positive infinity or negative infinity and false otherwise.",18,[[["self"]],["bool"]]],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",18,[[["self"]],["bool"]]],[10,"is_normal","","Returns `true` if the number is neither zero, infinite, [subnormal][subnormal], or `NaN`.",18,[[["self"]],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.",18,[[["self"]],["fpcategory"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",18,[[["self"]],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",18,[[["self"]],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",18,[[["self"]],["self"]]],[10,"trunc","","Return the integer part of a number.",18,[[["self"]],["self"]]],[10,"fract","","Returns the fractional part of a number.",18,[[["self"]],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.",18,[[["self"]],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",18,[[["self"]],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and since Rust 1.20 also `Float::nan()`.",18,[[["self"]],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and since Rust 1.20 also `-Float::nan()`.",18,[[["self"]],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",18,[[["self"],["self"],["self"]],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",18,[[["self"]],["self"]]],[10,"powi","","Raise a number to an integer power.",18,[[["self"],["i32"]],["self"]]],[10,"powf","","Raise a number to a floating point power.",18,[[["self"],["self"]],["self"]]],[10,"sqrt","","Take the square root of a number.",18,[[["self"]],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",18,[[["self"]],["self"]]],[10,"exp2","","Returns `2^(self)`.",18,[[["self"]],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",18,[[["self"]],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",18,[[["self"],["self"]],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",18,[[["self"]],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",18,[[["self"]],["self"]]],[11,"to_degrees","","Converts radians to degrees.",18,[[["self"]],["self"]]],[11,"to_radians","","Converts degrees to radians.",18,[[["self"]],["self"]]],[10,"max","","Returns the maximum of the two numbers.",18,[[["self"],["self"]],["self"]]],[10,"min","","Returns the minimum of the two numbers.",18,[[["self"],["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",18,[[["self"],["self"]],["self"]]],[10,"cbrt","","Take the cubic root of a number.",18,[[["self"]],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",18,[[["self"],["self"]],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",18,[[["self"]],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",18,[[["self"]],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",18,[[["self"]],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",18,[[["self"]],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",18,[[["self"]],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];",18,[[["self"]],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",18,[[["self"],["self"]],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.",18,N],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",18,[[["self"]],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",18,[[["self"]],["self"]]],[10,"sinh","","Hyperbolic sine function.",18,[[["self"]],["self"]]],[10,"cosh","","Hyperbolic cosine function.",18,[[["self"]],["self"]]],[10,"tanh","","Hyperbolic tangent function.",18,[[["self"]],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",18,[[["self"]],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",18,[[["self"]],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",18,[[["self"]],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively. The original number can be recovered by `sign * mantissa * 2 ^ exponent`.",18,N],[0,"bigint","","",N,N],[3,"ParseBigIntError","num::bigint","",N,N],[8,"ToBigInt","","A generic trait for converting a value to a `BigInt`.",N,N],[10,"to_bigint","","Converts the value of `self` to a `BigInt`.",19,[[["self"]],["option",["bigint"]]]],[3,"BigInt","","A big signed integer type.",N,N],[8,"ToBigUint","","A generic trait for converting a value to a `BigUint`.",N,N],[10,"to_biguint","","Converts the value of `self` to a `BigUint`.",20,[[["self"]],["option",["biguint"]]]],[4,"Sign","","A Sign is a `BigInt`'s composing element.",N,N],[13,"Minus","","",21,N],[13,"NoSign","","",21,N],[13,"Plus","","",21,N],[3,"BigUint","","A big unsigned integer type.",N,N],[0,"complex","num","",N,N],[3,"Complex","num::complex","A complex number in Cartesian form.",N,N],[12,"re","","Real portion of the complex number",0,N],[12,"im","","Imaginary portion of the complex number",0,N],[6,"Complex32","","",N,N],[6,"Complex64","","",N,N],[3,"ParseComplexError","","",N,N],[0,"integer","num","",N,N],[8,"Integer","num::integer","",N,N],[10,"div_floor","","Floored integer division.",1,[[["self"],["self"]],["self"]]],[10,"mod_floor","","Floored integer modulo, satisfying:",1,[[["self"],["self"]],["self"]]],[10,"gcd","","Greatest Common Divisor (GCD).",1,[[["self"],["self"]],["self"]]],[10,"lcm","","Lowest Common Multiple (LCM).",1,[[["self"],["self"]],["self"]]],[10,"divides","","Deprecated, use `is_multiple_of` instead.",1,[[["self"],["self"]],["bool"]]],[10,"is_multiple_of","","Returns `true` if `self` is a multiple of `other`.",1,[[["self"],["self"]],["bool"]]],[10,"is_even","","Returns `true` if the number is even.",1,[[["self"]],["bool"]]],[10,"is_odd","","Returns `true` if the number is odd.",1,[[["self"]],["bool"]]],[10,"div_rem","","Simultaneous truncated integer division and modulus. Returns `(quotient, remainder)`.",1,N],[11,"div_mod_floor","","Simultaneous floored integer division and modulus. Returns `(quotient, remainder)`.",1,N],[5,"div_rem","","Simultaneous integer division and modulus",N,N],[5,"div_floor","","Floored integer division",N,[[["t"],["t"]],["t"]]],[5,"mod_floor","","Floored integer modulus",N,[[["t"],["t"]],["t"]]],[5,"div_mod_floor","","Simultaneous floored integer division and modulus",N,N],[5,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`. The result is always positive.",N,[[["t"],["t"]],["t"]]],[5,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",N,[[["t"],["t"]],["t"]]],[3,"IterBinomial","","An iterator over binomial coefficients.",N,N],[5,"binomial","","Calculate the binomial coefficient.",N,[[["t"],["t"]],["t"]]],[5,"multinomial","","Calculate the multinomial coefficient.",N,N],[5,"nth_root","","Returns the truncated principal `n`th root of an integer -- see Roots::nth_root.",N,[[["t"],["u32"]],["t"]]],[8,"Roots","","Provides methods to compute an integer's square root, cube root, and arbitrary `n`th root.",N,N],[10,"nth_root","","Returns the truncated principal `n`th root of an integer -- `if x >= 0 { ⌊ⁿ√x⌋ } else { ⌈ⁿ√x⌉ }`",22,[[["self"],["u32"]],["self"]]],[11,"sqrt","","Returns the truncated principal square root of an integer -- `⌊√x⌋`",22,[[["self"]],["self"]]],[11,"cbrt","","Returns the truncated principal cube root of an integer -- `if x >= 0 { ⌊∛x⌋ } else { ⌈∛x⌉ }`",22,[[["self"]],["self"]]],[5,"cbrt","","Returns the truncated principal cube root of an integer -- see Roots::cbrt.",N,[[["t"]],["t"]]],[5,"sqrt","","Returns the truncated principal square root of an integer -- see Roots::sqrt.",N,[[["t"]],["t"]]],[0,"iter","num","",N,N],[3,"Range","num::iter","An iterator over the range [start, stop)",N,N],[5,"range","","Returns an iterator over the given range [start, stop) (that is, starting at start (inclusive), and ending at stop (exclusive)).",N,[[["a"],["a"]],["range"]]],[3,"RangeInclusive","","An iterator over the range [start, stop]",N,N],[5,"range_inclusive","","Return an iterator over the range [start, stop]",N,[[["a"],["a"]],["rangeinclusive"]]],[3,"RangeStep","","An iterator over the range [start, stop) by `step`. It handles overflow by stopping.",N,N],[5,"range_step","","Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.",N,[[["a"],["a"],["a"]],["rangestep"]]],[3,"RangeStepInclusive","","An iterator over the range [start, stop] by `step`. It handles overflow by stopping.",N,N],[5,"range_step_inclusive","","Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.",N,[[["a"],["a"],["a"]],["rangestepinclusive"]]],[0,"traits","num","",N,N],[0,"bounds","num::traits","",N,N],[8,"Bounded","num::traits::bounds","Numbers which have upper and lower bounds",N,N],[10,"min_value","","returns the smallest finite number this type can represent",6,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",6,[[],["self"]]],[0,"cast","num::traits","",N,N],[8,"ToPrimitive","num::traits::cast","A generic trait for converting a value to a number.",N,N],[11,"to_isize","","Converts the value of `self` to an `isize`.",13,[[["self"]],["option",["isize"]]]],[11,"to_i8","","Converts the value of `self` to an `i8`.",13,[[["self"]],["option",["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`.",13,[[["self"]],["option",["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`.",13,[[["self"]],["option",["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`.",13,[[["self"]],["option",["i64"]]]],[11,"to_i128","","Converts the value of `self` to an `i128`.",13,[[["self"]],["option",["i128"]]]],[11,"to_usize","","Converts the value of `self` to a `usize`.",13,[[["self"]],["option",["usize"]]]],[11,"to_u8","","Converts the value of `self` to an `u8`.",13,[[["self"]],["option",["u8"]]]],[11,"to_u16","","Converts the value of `self` to an `u16`.",13,[[["self"]],["option",["u16"]]]],[11,"to_u32","","Converts the value of `self` to an `u32`.",13,[[["self"]],["option",["u32"]]]],[10,"to_u64","","Converts the value of `self` to an `u64`.",13,[[["self"]],["option",["u64"]]]],[11,"to_u128","","Converts the value of `self` to an `u128`.",13,[[["self"]],["option",["u128"]]]],[11,"to_f32","","Converts the value of `self` to an `f32`.",13,[[["self"]],["option",["f32"]]]],[11,"to_f64","","Converts the value of `self` to an `f64`.",13,[[["self"]],["option",["f64"]]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",N,N],[11,"from_isize","","Convert an `isize` to return an optional value of this type. If the value cannot be represented by this value, then `None` is returned.",14,[[["isize"]],["option"]]],[11,"from_i8","","Convert an `i8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i8"]],["option"]]],[11,"from_i16","","Convert an `i16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i16"]],["option"]]],[11,"from_i32","","Convert an `i32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i32"]],["option"]]],[10,"from_i64","","Convert an `i64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i64"]],["option"]]],[11,"from_i128","","Convert an `i128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["i128"]],["option"]]],[11,"from_usize","","Convert a `usize` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["usize"]],["option"]]],[11,"from_u8","","Convert an `u8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u8"]],["option"]]],[11,"from_u16","","Convert an `u16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u16"]],["option"]]],[11,"from_u32","","Convert an `u32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u32"]],["option"]]],[10,"from_u64","","Convert an `u64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u64"]],["option"]]],[11,"from_u128","","Convert an `u128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["u128"]],["option"]]],[11,"from_f32","","Convert a `f32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["f32"]],["option"]]],[11,"from_f64","","Convert a `f64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",14,[[["f64"]],["option"]]],[5,"cast","","Cast from one machine scalar to another.",N,[[["t"]],["option"]]],[8,"NumCast","","An interface for casting between machine scalars.",N,N],[10,"from","","Creates a number from another value that can be converted into a primitive via the `ToPrimitive` trait.",15,[[["t"]],["option"]]],[8,"AsPrimitive","","A generic interface for casting between machine scalars with the `as` operator, which admits narrowing and precision loss. Implementers of this trait AsPrimitive should behave like a primitive numeric type (e.g. a newtype around another primitive), and the intended conversion must never fail.",N,N],[10,"as_","","Convert a value to another, using the `as` operator.",16,[[["self"]],["t"]]],[0,"float","num::traits","",N,N],[8,"FloatCore","num::traits::float","Generic trait for floating point numbers that works with `no_std`.",N,N],[10,"infinity","","Returns positive infinity.",23,[[],["self"]]],[10,"neg_infinity","","Returns negative infinity.",23,[[],["self"]]],[10,"nan","","Returns NaN.",23,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",23,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can represent.",23,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",23,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",23,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can represent.",23,[[],["self"]]],[11,"is_nan","","Returns `true` if the number is NaN.",23,[[["self"]],["bool"]]],[11,"is_infinite","","Returns `true` if the number is infinite.",23,[[["self"]],["bool"]]],[11,"is_finite","","Returns `true` if the number is neither infinite or NaN.",23,[[["self"]],["bool"]]],[11,"is_normal","","Returns `true` if the number is neither zero, infinite, subnormal or NaN.",23,[[["self"]],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.",23,[[["self"]],["fpcategory"]]],[11,"floor","","Returns the largest integer less than or equal to a number.",23,[[["self"]],["self"]]],[11,"ceil","","Returns the smallest integer greater than or equal to a number.",23,[[["self"]],["self"]]],[11,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",23,[[["self"]],["self"]]],[11,"trunc","","Return the integer part of a number.",23,[[["self"]],["self"]]],[11,"fract","","Returns the fractional part of a number.",23,[[["self"]],["self"]]],[11,"abs","","Computes the absolute value of `self`. Returns `FloatCore::nan()` if the number is `FloatCore::nan()`.",23,[[["self"]],["self"]]],[11,"signum","","Returns a number that represents the sign of `self`.",23,[[["self"]],["self"]]],[11,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0` and `FloatCore::infinity()`, and since Rust 1.20 also `FloatCore::nan()`.",23,[[["self"]],["bool"]]],[11,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0` and `FloatCore::neg_infinity()`, and since Rust 1.20 also `-FloatCore::nan()`.",23,[[["self"]],["bool"]]],[11,"min","","Returns the minimum of the two numbers.",23,[[["self"],["self"]],["self"]]],[11,"max","","Returns the maximum of the two numbers.",23,[[["self"],["self"]],["self"]]],[11,"recip","","Returns the reciprocal (multiplicative inverse) of the number.",23,[[["self"]],["self"]]],[11,"powi","","Raise a number to an integer power.",23,[[["self"],["i32"]],["self"]]],[10,"to_degrees","","Converts to degrees, assuming the number is in radians.",23,[[["self"]],["self"]]],[10,"to_radians","","Converts to radians, assuming the number is in degrees.",23,[[["self"]],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively. The original number can be recovered by `sign * mantissa * 2 ^ exponent`.",23,N],[8,"Float","","Generic trait for floating point numbers",N,N],[10,"nan","","Returns the `NaN` value.",18,[[],["self"]]],[10,"infinity","","Returns the infinite value.",18,[[],["self"]]],[10,"neg_infinity","","Returns the negative infinite value.",18,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",18,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can represent.",18,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",18,[[],["self"]]],[11,"epsilon","","Returns epsilon, a small positive value.",18,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can represent.",18,[[],["self"]]],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",18,[[["self"]],["bool"]]],[10,"is_infinite","","Returns `true` if this value is positive infinity or negative infinity and false otherwise.",18,[[["self"]],["bool"]]],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",18,[[["self"]],["bool"]]],[10,"is_normal","","Returns `true` if the number is neither zero, infinite, [subnormal][subnormal], or `NaN`.",18,[[["self"]],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.",18,[[["self"]],["fpcategory"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",18,[[["self"]],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",18,[[["self"]],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",18,[[["self"]],["self"]]],[10,"trunc","","Return the integer part of a number.",18,[[["self"]],["self"]]],[10,"fract","","Returns the fractional part of a number.",18,[[["self"]],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.",18,[[["self"]],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",18,[[["self"]],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and since Rust 1.20 also `Float::nan()`.",18,[[["self"]],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and since Rust 1.20 also `-Float::nan()`.",18,[[["self"]],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",18,[[["self"],["self"],["self"]],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",18,[[["self"]],["self"]]],[10,"powi","","Raise a number to an integer power.",18,[[["self"],["i32"]],["self"]]],[10,"powf","","Raise a number to a floating point power.",18,[[["self"],["self"]],["self"]]],[10,"sqrt","","Take the square root of a number.",18,[[["self"]],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",18,[[["self"]],["self"]]],[10,"exp2","","Returns `2^(self)`.",18,[[["self"]],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",18,[[["self"]],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",18,[[["self"],["self"]],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",18,[[["self"]],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",18,[[["self"]],["self"]]],[11,"to_degrees","","Converts radians to degrees.",18,[[["self"]],["self"]]],[11,"to_radians","","Converts degrees to radians.",18,[[["self"]],["self"]]],[10,"max","","Returns the maximum of the two numbers.",18,[[["self"],["self"]],["self"]]],[10,"min","","Returns the minimum of the two numbers.",18,[[["self"],["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",18,[[["self"],["self"]],["self"]]],[10,"cbrt","","Take the cubic root of a number.",18,[[["self"]],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",18,[[["self"],["self"]],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",18,[[["self"]],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",18,[[["self"]],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",18,[[["self"]],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",18,[[["self"]],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",18,[[["self"]],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];",18,[[["self"]],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",18,[[["self"],["self"]],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.",18,N],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",18,[[["self"]],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",18,[[["self"]],["self"]]],[10,"sinh","","Hyperbolic sine function.",18,[[["self"]],["self"]]],[10,"cosh","","Hyperbolic cosine function.",18,[[["self"]],["self"]]],[10,"tanh","","Hyperbolic tangent function.",18,[[["self"]],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",18,[[["self"]],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",18,[[["self"]],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",18,[[["self"]],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively. The original number can be recovered by `sign * mantissa * 2 ^ exponent`.",18,N],[8,"FloatConst","","",N,N],[10,"E","","Return Euler’s number.",24,[[],["self"]]],[10,"FRAC_1_PI","","Return `1.0 / π`.",24,[[],["self"]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",24,[[],["self"]]],[10,"FRAC_2_PI","","Return `2.0 / π`.",24,[[],["self"]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",24,[[],["self"]]],[10,"FRAC_PI_2","","Return `π / 2.0`.",24,[[],["self"]]],[10,"FRAC_PI_3","","Return `π / 3.0`.",24,[[],["self"]]],[10,"FRAC_PI_4","","Return `π / 4.0`.",24,[[],["self"]]],[10,"FRAC_PI_6","","Return `π / 6.0`.",24,[[],["self"]]],[10,"FRAC_PI_8","","Return `π / 8.0`.",24,[[],["self"]]],[10,"LN_10","","Return `ln(10.0)`.",24,[[],["self"]]],[10,"LN_2","","Return `ln(2.0)`.",24,[[],["self"]]],[10,"LOG10_E","","Return `log10(e)`.",24,[[],["self"]]],[10,"LOG2_E","","Return `log2(e)`.",24,[[],["self"]]],[10,"PI","","Return Archimedes’ constant.",24,[[],["self"]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",24,[[],["self"]]],[0,"identities","num::traits","",N,N],[8,"Zero","num::traits::identities","Defines an additive identity element for `Self`.",N,N],[10,"zero","","Returns the additive identity element of `Self`, `0`.",3,[[],["self"]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",3,[[["self"]],["bool"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",N,N],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",4,[[],["self"]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative identity.",4,[[["self"]],["bool"]]],[5,"zero","","Returns the additive identity, `0`.",N,[[],["t"]]],[5,"one","","Returns the multiplicative identity, `1`.",N,[[],["t"]]],[0,"int","num::traits","",N,N],[8,"PrimInt","num::traits::int","",N,N],[10,"count_ones","","Returns the number of ones in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount, `n`, wrapping the truncated bits to the end of the resulting integer.",12,[[["self"],["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount, `n`, wrapping the truncated bits to the beginning of the resulting integer.",12,[[["self"],["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",12,[[["self"],["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount, `n`, copying the \"sign bit\" in the most significant bits even for unsigned types.",12,[[["self"],["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",12,[[["self"],["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount, `n`, filling zeros in the most significant bits.",12,[[["self"],["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",12,[[["self"]],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's endianness.",12,[[["self"]],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's endianness.",12,[[["self"]],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",12,[[["self"]],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's endianness.",12,[[["self"]],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by squaring.",12,[[["self"],["u32"]],["self"]]],[0,"ops","num::traits","",N,N],[0,"checked","num::traits::ops","",N,N],[8,"CheckedAdd","num::traits::ops::checked","Performs addition that returns `None` instead of wrapping around on overflow.",N,N],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow happens, `None` is returned.",8,[[["self"],["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of wrapping around on underflow.",N,N],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.",9,[[["self"],["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of wrapping around on underflow or overflow.",N,N],[10,"checked_mul","","Multiplies two numbers, checking for underflow or overflow. If underflow or overflow happens, `None` is returned.",10,[[["self"],["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking on division by zero and instead of wrapping around on underflow and overflow.",N,N],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and division by zero. If any of that happens, `None` is returned.",11,[[["self"],["self"]],["option"]]],[8,"CheckedRem","","Performs an integral remainder that returns `None` instead of panicking on division by zero and instead of wrapping around on underflow and overflow.",N,N],[10,"checked_rem","","Finds the remainder of dividing two numbers, checking for underflow, overflow and division by zero. If any of that happens, `None` is returned.",25,[[["self"],["self"]],["option"]]],[8,"CheckedNeg","","Performs negation that returns `None` if the result can't be represented.",N,N],[10,"checked_neg","","Negates a number, returning `None` for results that can't be represented, like signed `MIN` values that can't be positive, or non-zero unsigned values that can't be negative.",26,[[["self"]],["option"]]],[8,"CheckedShl","","Performs a left shift that returns `None` on overflow.",N,N],[10,"checked_shl","","Shifts a number to the left, checking for overflow. If overflow happens, `None` is returned.",27,[[["self"],["u32"]],["option"]]],[8,"CheckedShr","","Performs a right shift that returns `None` on overflow.",N,N],[10,"checked_shr","","Shifts a number to the left, checking for overflow. If overflow happens, `None` is returned.",28,[[["self"],["u32"]],["option"]]],[0,"inv","num::traits::ops","",N,N],[8,"Inv","num::traits::ops::inv","Unary operator for retrieving the multiplicative inverse, or reciprocal, of a value.",N,N],[16,"Output","","The result after applying the operator.",29,N],[10,"inv","","Returns the multiplicative inverse of `self`.",29,N],[0,"mul_add","num::traits::ops","",N,N],[8,"MulAdd","num::traits::ops::mul_add","Fused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",N,N],[16,"Output","","The resulting type after applying the fused multiply-add.",30,N],[10,"mul_add","","Performs the fused multiply-add operation.",30,N],[8,"MulAddAssign","","The fused multiply-add assignment operation.",N,N],[10,"mul_add_assign","","Performs the fused multiply-add operation.",31,N],[0,"saturating","num::traits::ops","",N,N],[8,"Saturating","num::traits::ops::saturating","Saturating math operations",N,N],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at the numeric bounds instead of overflowing.",7,[[["self"],["self"]],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating at the numeric bounds instead of overflowing.",7,[[["self"],["self"]],["self"]]],[0,"wrapping","num::traits::ops","",N,N],[8,"WrappingAdd","num::traits::ops::wrapping","Performs addition that wraps around on overflow.",N,N],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`, wrapping around at the boundary of the type.",32,[[["self"],["self"]],["self"]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",N,N],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`, wrapping around at the boundary of the type.",33,[[["self"],["self"]],["self"]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",N,N],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self * other`, wrapping around at the boundary of the type.",34,[[["self"],["self"]],["self"]]],[8,"WrappingShl","","Performs a left shift that does not panic.",N,N],[10,"wrapping_shl","","Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes any high order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.",35,[[["self"],["u32"]],["self"]]],[8,"WrappingShr","","Performs a right shift that does not panic.",N,N],[10,"wrapping_shr","","Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask` removes any high order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.",36,[[["self"],["u32"]],["self"]]],[0,"pow","num::traits","",N,N],[8,"Pow","num::traits::pow","Binary operator for raising a value to a power.",N,N],[16,"Output","","The result after applying the operator.",17,N],[10,"pow","","Returns `self` to the power `rhs`.",17,N],[5,"pow","","Raises a value to the power of exp, using exponentiation by squaring.",N,[[["t"],["usize"]],["t"]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an overflow occurred.",N,[[["t"],["usize"]],["option"]]],[0,"real","num::traits","",N,N],[8,"Real","num::traits::real","A trait for real number types that do not necessarily have floating-point-specific characteristics such as NaN and infinity.",N,N],[10,"min_value","","Returns the smallest finite value that this type can represent.",37,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",37,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",37,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can represent.",37,[[],["self"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",37,[[["self"]],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",37,[[["self"]],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",37,[[["self"]],["self"]]],[10,"trunc","","Return the integer part of a number.",37,[[["self"]],["self"]]],[10,"fract","","Returns the fractional part of a number.",37,[[["self"]],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.",37,[[["self"]],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",37,[[["self"]],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and with newer versions of Rust `f64::NAN`.",37,[[["self"]],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and with newer versions of Rust `-f64::NAN`.",37,[[["self"]],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",37,[[["self"],["self"],["self"]],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",37,[[["self"]],["self"]]],[10,"powi","","Raise a number to an integer power.",37,[[["self"],["i32"]],["self"]]],[10,"powf","","Raise a number to a real number power.",37,[[["self"],["self"]],["self"]]],[10,"sqrt","","Take the square root of a number.",37,[[["self"]],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",37,[[["self"]],["self"]]],[10,"exp2","","Returns `2^(self)`.",37,[[["self"]],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",37,[[["self"]],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",37,[[["self"],["self"]],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",37,[[["self"]],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",37,[[["self"]],["self"]]],[10,"to_degrees","","Converts radians to degrees.",37,[[["self"]],["self"]]],[10,"to_radians","","Converts degrees to radians.",37,[[["self"]],["self"]]],[10,"max","","Returns the maximum of the two numbers.",37,[[["self"],["self"]],["self"]]],[10,"min","","Returns the minimum of the two numbers.",37,[[["self"],["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",37,[[["self"],["self"]],["self"]]],[10,"cbrt","","Take the cubic root of a number.",37,[[["self"]],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",37,[[["self"],["self"]],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",37,[[["self"]],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",37,[[["self"]],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",37,[[["self"]],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",37,[[["self"]],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",37,[[["self"]],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];",37,[[["self"]],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",37,[[["self"],["self"]],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.",37,N],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",37,[[["self"]],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",37,[[["self"]],["self"]]],[10,"sinh","","Hyperbolic sine function.",37,[[["self"]],["self"]]],[10,"cosh","","Hyperbolic cosine function.",37,[[["self"]],["self"]]],[10,"tanh","","Hyperbolic tangent function.",37,[[["self"]],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",37,[[["self"]],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",37,[[["self"]],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",37,[[["self"]],["self"]]],[0,"sign","num::traits","",N,N],[8,"Signed","num::traits::sign","Useful functions for signed numbers (i.e. numbers that can be negative).",N,N],[10,"abs","","Computes the absolute value.",5,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",5,[[["self"],["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",5,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",5,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",5,[[["self"]],["bool"]]],[5,"abs","","Computes the absolute value.",N,[[["t"]],["t"]]],[5,"abs_sub","","The positive difference of two numbers.",N,[[["t"],["t"]],["t"]]],[5,"signum","","Returns the sign of the number.",N,[[["t"]],["t"]]],[8,"Unsigned","","A trait for values which cannot be negative",N,N],[8,"Num","num::traits","The base trait for numeric types, covering `0` and `1` values, comparisons, basic numeric operations, and string conversion.",N,N],[16,"FromStrRadixErr","","",2,N],[10,"from_str_radix","","Convert from a string and radix <= 36.",2,[[["str"],["u32"]],["result"]]],[8,"NumOps","","The trait for types implementing basic numeric operations",N,N],[8,"NumRef","","The trait for `Num` types which also implement numeric operations taking the second operand by reference.",N,N],[8,"RefNum","","The trait for references which implement numeric operations, taking the second operand either by value or by reference.",N,N],[8,"NumAssignOps","","The trait for types implementing numeric assignment operators (like `+=`).",N,N],[8,"NumAssign","","The trait for `Num` types which also implement assignment operators.",N,N],[8,"NumAssignRef","","The trait for `NumAssign` types which also implement assignment operations taking the second operand by reference.",N,N],[4,"FloatErrorKind","","",N,N],[13,"Empty","","",38,N],[13,"Invalid","","",38,N],[3,"ParseFloatError","","",N,N],[12,"kind","","",39,N],[5,"clamp","","A value bounded by a minimum and a maximum",N,[[["t"],["t"],["t"]],["t"]]],[0,"rational","num","",N,N],[3,"Ratio","num::rational","Represents the ratio between two numbers.",N,N],[6,"Rational","","Alias for a `Ratio` of machine-sized integers.",N,N],[6,"Rational32","","Alias for a `Ratio` of 32-bit-sized integers.",N,N],[6,"Rational64","","Alias for a `Ratio` of 64-bit-sized integers.",N,N],[6,"BigRational","","Alias for arbitrary precision rationals.",N,N],[3,"ParseRatioError","","",N,N],[11,"try_from","num::bigint","",40,[[["u"]],["result"]]],[11,"from","","",40,[[["t"]],["t"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"to_owned","","",40,[[["self"]],["t"]]],[11,"clone_into","","",40,N],[11,"to_string","","",40,[[["self"]],["string"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"from","","",41,[[["t"]],["t"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"to_owned","","",41,[[["self"]],["t"]]],[11,"clone_into","","",41,N],[11,"to_string","","",41,[[["self"]],["string"]]],[11,"try_from","num::complex","",0,[[["u"]],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","num::bigint","",42,[[["u"]],["result"]]],[11,"from","","",42,[[["t"]],["t"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"to_owned","","",42,[[["self"]],["t"]]],[11,"clone_into","","",42,N],[11,"to_string","","",42,[[["self"]],["string"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"to_owned","","",21,[[["self"]],["t"]]],[11,"clone_into","","",21,N],[11,"try_from","num::complex","",43,[[["u"]],["result"]]],[11,"from","","",43,[[["t"]],["t"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"to_string","","",43,[[["self"]],["string"]]],[11,"try_from","num::integer","",44,[[["u"]],["result"]]],[11,"into_iter","","",44,[[["self"]],["i"]]],[11,"from","","",44,[[["t"]],["t"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"try_from","num::iter","",45,[[["u"]],["result"]]],[11,"into_iter","","",45,[[["self"]],["i"]]],[11,"from","","",45,[[["t"]],["t"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"to_owned","","",45,[[["self"]],["t"]]],[11,"clone_into","","",45,N],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"into_iter","","",46,[[["self"]],["i"]]],[11,"from","","",46,[[["t"]],["t"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"to_owned","","",46,[[["self"]],["t"]]],[11,"clone_into","","",46,N],[11,"try_from","","",47,[[["u"]],["result"]]],[11,"into_iter","","",47,[[["self"]],["i"]]],[11,"from","","",47,[[["t"]],["t"]]],[11,"try_into","","",47,[[["self"]],["result"]]],[11,"into","","",47,[[["self"]],["u"]]],[11,"borrow","","",47,[[["self"]],["t"]]],[11,"borrow_mut","","",47,[[["self"]],["t"]]],[11,"get_type_id","","",47,[[["self"]],["typeid"]]],[11,"to_owned","","",47,[[["self"]],["t"]]],[11,"clone_into","","",47,N],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"into_iter","","",48,[[["self"]],["i"]]],[11,"from","","",48,[[["t"]],["t"]]],[11,"try_into","","",48,[[["self"]],["result"]]],[11,"into","","",48,[[["self"]],["u"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"get_type_id","","",48,[[["self"]],["typeid"]]],[11,"to_owned","","",48,[[["self"]],["t"]]],[11,"clone_into","","",48,N],[11,"try_from","num::traits","",38,[[["u"]],["result"]]],[11,"from","","",38,[[["t"]],["t"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"into","","",38,[[["self"]],["u"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"from","","",39,[[["t"]],["t"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"to_string","","",39,[[["self"]],["string"]]],[11,"try_from","num::rational","",49,[[["u"]],["result"]]],[11,"from","","",49,[[["t"]],["t"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"into","","",49,[[["self"]],["u"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"to_owned","","",49,[[["self"]],["t"]]],[11,"clone_into","","",49,N],[11,"to_string","","",49,[[["self"]],["string"]]],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"from","","",50,[[["t"]],["t"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"to_owned","","",50,[[["self"]],["t"]]],[11,"clone_into","","",50,N],[11,"to_string","","",50,[[["self"]],["string"]]],[11,"abs","num::bigint","",40,[[["self"]],["bigint"]]],[11,"abs_sub","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"signum","","",40,[[["self"]],["bigint"]]],[11,"is_positive","","",40,[[["self"]],["bool"]]],[11,"is_negative","","",40,[[["self"]],["bool"]]],[11,"shl_assign","","",41,N],[11,"shl_assign","","",40,N],[11,"clone","","",21,[[["self"]],["sign"]]],[11,"clone","","",41,[[["self"]],["biguint"]]],[11,"clone","","",40,[[["self"]],["bigint"]]],[11,"clone","","",42,[[["self"]],["parsebiginterror"]]],[11,"checked_sub","","",40,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_sub","","",41,[[["self"],["biguint"]],["option",["biguint"]]]],[11,"shl","","",41,[[["self"],["usize"]],["biguint"]]],[11,"shl","","",40,[[["self"],["usize"]],["bigint"]]],[11,"add_assign","","",40,N],[11,"add_assign","","",40,N],[11,"add_assign","","",40,N],[11,"add_assign","","",40,N],[11,"add_assign","","",40,N],[11,"add_assign","","",40,N],[11,"add_assign","","",41,N],[11,"add_assign","","",41,N],[11,"add_assign","","",41,N],[11,"add_assign","","",40,N],[11,"add_assign","","",40,N],[11,"add_assign","","",41,N],[11,"add_assign","","",40,N],[11,"add_assign","","",40,N],[11,"add_assign","","",41,N],[11,"add_assign","","",40,N],[11,"add_assign","","",40,N],[11,"add_assign","","",40,N],[11,"add_assign","","",40,N],[11,"add_assign","","",41,N],[11,"add_assign","","",41,N],[11,"add_assign","","",41,N],[11,"fmt","","",40,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result",["error"]]]],[11,"mul_assign","","",41,N],[11,"mul_assign","","",41,N],[11,"mul_assign","","",40,N],[11,"mul_assign","","",40,N],[11,"mul_assign","","",41,N],[11,"mul_assign","","",41,N],[11,"mul_assign","","",40,N],[11,"mul_assign","","",40,N],[11,"mul_assign","","",40,N],[11,"mul_assign","","",40,N],[11,"mul_assign","","",40,N],[11,"mul_assign","","",40,N],[11,"mul_assign","","",40,N],[11,"mul_assign","","",40,N],[11,"mul_assign","","",41,N],[11,"mul_assign","","",40,N],[11,"mul_assign","","",41,N],[11,"mul_assign","","",40,N],[11,"mul_assign","","",41,N],[11,"mul_assign","","",40,N],[11,"mul_assign","","",41,N],[11,"mul_assign","","",40,N],[11,"cmp","","",40,[[["self"],["bigint"]],["ordering"]]],[11,"cmp","","",21,[[["self"],["sign"]],["ordering"]]],[11,"cmp","","",41,[[["self"],["biguint"]],["ordering"]]],[11,"from_str_radix","","Creates and initializes a `BigUint`.",41,[[["str"],["u32"]],["result",["biguint","parsebiginterror"]]]],[11,"from_str_radix","","Creates and initializes a BigInt.",40,[[["str"],["u32"]],["result",["bigint","parsebiginterror"]]]],[11,"default","","",41,[[],["biguint"]]],[11,"default","","",40,[[],["bigint"]]],[11,"add","","",40,[[["self"],["u16"]],["bigint"]]],[11,"add","","",41,[[["self"],["u32"]],["biguint"]]],[11,"add","","",40,[[["self"],["usize"]],["bigint"]]],[11,"add","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"add","","",41,[[["self"],["u128"]],["biguint"]]],[11,"add","","",40,[[["self"],["i128"]],["bigint"]]],[11,"add","","",41,[[["self"],["usize"]],["biguint"]]],[11,"add","","",40,[[["self"],["u32"]],["bigint"]]],[11,"add","","",41,[[["self"],["u128"]],["biguint"]]],[11,"add","","",40,[[["self"],["u16"]],["bigint"]]],[11,"add","","",40,[[["self"],["usize"]],["bigint"]]],[11,"add","","",41,[[["self"],["u16"]],["biguint"]]],[11,"add","","",41,[[["self"],["usize"]],["biguint"]]],[11,"add","","",40,[[["self"],["u64"]],["bigint"]]],[11,"add","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"add","","",40,[[["self"],["isize"]],["bigint"]]],[11,"add","","",40,[[["self"],["i16"]],["bigint"]]],[11,"add","","",40,[[["self"],["i64"]],["bigint"]]],[11,"add","","",40,[[["self"],["i8"]],["bigint"]]],[11,"add","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"add","","",40,[[["self"],["u64"]],["bigint"]]],[11,"add","","",40,[[["self"],["i128"]],["bigint"]]],[11,"add","","",41,[[["self"],["u64"]],["biguint"]]],[11,"add","","",40,[[["self"],["u8"]],["bigint"]]],[11,"add","","",41,[[["self"],["u64"]],["biguint"]]],[11,"add","","",41,[[["self"],["u32"]],["biguint"]]],[11,"add","","",41,[[["self"],["u16"]],["biguint"]]],[11,"add","","",40,[[["self"],["isize"]],["bigint"]]],[11,"add","","",40,[[["self"],["u32"]],["bigint"]]],[11,"add","","",40,[[["self"],["i32"]],["bigint"]]],[11,"add","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"add","","",40,[[["self"],["i16"]],["bigint"]]],[11,"add","","",40,[[["self"],["i8"]],["bigint"]]],[11,"add","","",41,[[["self"],["u8"]],["biguint"]]],[11,"add","","",40,[[["self"],["i64"]],["bigint"]]],[11,"add","","",40,[[["self"],["u8"]],["bigint"]]],[11,"add","","",40,[[["self"],["u128"]],["bigint"]]],[11,"add","","",41,[[["self"],["u8"]],["biguint"]]],[11,"add","","",40,[[["self"],["i32"]],["bigint"]]],[11,"add","","",40,[[["self"],["u128"]],["bigint"]]],[11,"bitor_assign","","",40,N],[11,"bitor_assign","","",41,N],[11,"bitor_assign","","",40,N],[11,"bitor_assign","","",41,N],[11,"bitand_assign","","",40,N],[11,"bitand_assign","","",41,N],[11,"bitand_assign","","",41,N],[11,"bitand_assign","","",40,N],[11,"to_bigint","","",41,[[["self"]],["option",["bigint"]]]],[11,"to_bigint","","",40,[[["self"]],["option",["bigint"]]]],[11,"from_i64","","",40,[[["i64"]],["option",["bigint"]]]],[11,"from_i128","","",40,[[["i128"]],["option",["bigint"]]]],[11,"from_u64","","",40,[[["u64"]],["option",["bigint"]]]],[11,"from_u128","","",40,[[["u128"]],["option",["bigint"]]]],[11,"from_f64","","",40,[[["f64"]],["option",["bigint"]]]],[11,"from_i64","","",41,[[["i64"]],["option",["biguint"]]]],[11,"from_i128","","",41,[[["i128"]],["option",["biguint"]]]],[11,"from_u64","","",41,[[["u64"]],["option",["biguint"]]]],[11,"from_u128","","",41,[[["u128"]],["option",["biguint"]]]],[11,"from_f64","","",41,[[["f64"]],["option",["biguint"]]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",42,[[["self"],["formatter"]],["result",["error"]]]],[11,"bitor","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"bitor","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"bitor","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"bitor","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"to_biguint","","",40,[[["self"]],["option",["biguint"]]]],[11,"to_biguint","","",41,[[["self"]],["option",["biguint"]]]],[11,"checked_mul","","",41,[[["self"],["biguint"]],["option",["biguint"]]]],[11,"checked_mul","","",40,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"div_rem","","",40,N],[11,"div_floor","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"mod_floor","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"div_mod_floor","","",40,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",40,[[["self"],["bigint"]],["bigint"]]],[11,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",40,[[["self"],["bigint"]],["bigint"]]],[11,"divides","","Deprecated, use `is_multiple_of` instead.",40,[[["self"],["bigint"]],["bool"]]],[11,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",40,[[["self"],["bigint"]],["bool"]]],[11,"is_even","","Returns `true` if the number is divisible by `2`.",40,[[["self"]],["bool"]]],[11,"is_odd","","Returns `true` if the number is not divisible by `2`.",40,[[["self"]],["bool"]]],[11,"div_rem","","",41,N],[11,"div_floor","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"mod_floor","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"div_mod_floor","","",41,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",41,[[["self"],["biguint"]],["biguint"]]],[11,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",41,[[["self"],["biguint"]],["biguint"]]],[11,"divides","","Deprecated, use `is_multiple_of` instead.",41,[[["self"],["biguint"]],["bool"]]],[11,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",41,[[["self"],["biguint"]],["bool"]]],[11,"is_even","","Returns `true` if the number is divisible by `2`.",41,[[["self"]],["bool"]]],[11,"is_odd","","Returns `true` if the number is not divisible by `2`.",41,[[["self"]],["bool"]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result",["error"]]]],[11,"hash","","",21,N],[11,"hash","","",41,N],[11,"hash","","",40,N],[11,"fmt","","",41,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result",["error"]]]],[11,"bitxor","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"bitxor","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"bitxor","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"bitxor","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"shr","","",41,[[["self"],["usize"]],["biguint"]]],[11,"shr","","",40,[[["self"],["usize"]],["bigint"]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result",["error"]]]],[11,"sub_assign","","",40,N],[11,"sub_assign","","",40,N],[11,"sub_assign","","",41,N],[11,"sub_assign","","",41,N],[11,"sub_assign","","",40,N],[11,"sub_assign","","",41,N],[11,"sub_assign","","",40,N],[11,"sub_assign","","",40,N],[11,"sub_assign","","",40,N],[11,"sub_assign","","",41,N],[11,"sub_assign","","",40,N],[11,"sub_assign","","",41,N],[11,"sub_assign","","",41,N],[11,"sub_assign","","",40,N],[11,"sub_assign","","",40,N],[11,"sub_assign","","",40,N],[11,"sub_assign","","",40,N],[11,"sub_assign","","",41,N],[11,"sub_assign","","",40,N],[11,"sub_assign","","",40,N],[11,"sub_assign","","",40,N],[11,"sub_assign","","",41,N],[11,"partial_cmp","","",21,[[["self"],["sign"]],["option",["ordering"]]]],[11,"partial_cmp","","",41,[[["self"],["biguint"]],["option",["ordering"]]]],[11,"partial_cmp","","",40,[[["self"],["bigint"]],["option",["ordering"]]]],[11,"div","","",40,[[["self"],["i16"]],["bigint"]]],[11,"div","","",41,[[["self"],["u16"]],["biguint"]]],[11,"div","","",40,[[["self"],["usize"]],["bigint"]]],[11,"div","","",40,[[["self"],["i16"]],["bigint"]]],[11,"div","","",40,[[["self"],["u8"]],["bigint"]]],[11,"div","","",40,[[["self"],["u16"]],["bigint"]]],[11,"div","","",41,[[["self"],["u64"]],["biguint"]]],[11,"div","","",40,[[["self"],["i8"]],["bigint"]]],[11,"div","","",41,[[["self"],["usize"]],["biguint"]]],[11,"div","","",40,[[["self"],["i8"]],["bigint"]]],[11,"div","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"div","","",41,[[["self"],["u64"]],["biguint"]]],[11,"div","","",40,[[["self"],["u64"]],["bigint"]]],[11,"div","","",41,[[["self"],["u8"]],["biguint"]]],[11,"div","","",41,[[["self"],["u16"]],["biguint"]]],[11,"div","","",40,[[["self"],["i128"]],["bigint"]]],[11,"div","","",40,[[["self"],["i32"]],["bigint"]]],[11,"div","","",40,[[["self"],["u32"]],["bigint"]]],[11,"div","","",40,[[["self"],["isize"]],["bigint"]]],[11,"div","","",40,[[["self"],["i64"]],["bigint"]]],[11,"div","","",41,[[["self"],["u128"]],["biguint"]]],[11,"div","","",41,[[["self"],["u32"]],["biguint"]]],[11,"div","","",40,[[["self"],["isize"]],["bigint"]]],[11,"div","","",40,[[["self"],["u128"]],["bigint"]]],[11,"div","","",40,[[["self"],["u8"]],["bigint"]]],[11,"div","","",41,[[["self"],["usize"]],["biguint"]]],[11,"div","","",41,[[["self"],["u128"]],["biguint"]]],[11,"div","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"div","","",40,[[["self"],["u64"]],["bigint"]]],[11,"div","","",41,[[["self"],["u32"]],["biguint"]]],[11,"div","","",40,[[["self"],["u16"]],["bigint"]]],[11,"div","","",40,[[["self"],["i64"]],["bigint"]]],[11,"div","","",40,[[["self"],["i32"]],["bigint"]]],[11,"div","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"div","","",40,[[["self"],["i128"]],["bigint"]]],[11,"div","","",40,[[["self"],["u32"]],["bigint"]]],[11,"div","","",41,[[["self"],["u8"]],["biguint"]]],[11,"div","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"div","","",40,[[["self"],["u128"]],["bigint"]]],[11,"div","","",40,[[["self"],["usize"]],["bigint"]]],[11,"not","","",40,[[["self"]],["bigint"]]],[11,"checked_add","","",41,[[["self"],["biguint"]],["option",["biguint"]]]],[11,"checked_add","","",40,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"bitxor_assign","","",41,N],[11,"bitxor_assign","","",40,N],[11,"bitxor_assign","","",40,N],[11,"bitxor_assign","","",41,N],[11,"div_assign","","",41,N],[11,"div_assign","","",40,N],[11,"div_assign","","",41,N],[11,"div_assign","","",40,N],[11,"div_assign","","",40,N],[11,"div_assign","","",41,N],[11,"div_assign","","",40,N],[11,"div_assign","","",40,N],[11,"div_assign","","",40,N],[11,"div_assign","","",40,N],[11,"div_assign","","",41,N],[11,"div_assign","","",40,N],[11,"div_assign","","",40,N],[11,"div_assign","","",40,N],[11,"div_assign","","",41,N],[11,"div_assign","","",41,N],[11,"div_assign","","",40,N],[11,"div_assign","","",41,N],[11,"div_assign","","",41,N],[11,"div_assign","","",40,N],[11,"div_assign","","",40,N],[11,"div_assign","","",40,N],[11,"checked_div","","",40,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_div","","",41,[[["self"],["biguint"]],["option",["biguint"]]]],[11,"zero","","",40,[[],["bigint"]]],[11,"is_zero","","",40,[[["self"]],["bool"]]],[11,"zero","","",41,[[],["biguint"]]],[11,"is_zero","","",41,[[["self"]],["bool"]]],[11,"product","","",41,[[["i"]],["biguint"]]],[11,"product","","",40,[[["i"]],["bigint"]]],[11,"shr_assign","","",41,N],[11,"shr_assign","","",40,N],[11,"bitand","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"bitand","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"bitand","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"bitand","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"description","","",42,[[["self"]],["str"]]],[11,"one","","",40,[[],["bigint"]]],[11,"is_one","","",40,[[["self"]],["bool"]]],[11,"one","","",41,[[],["biguint"]]],[11,"is_one","","",41,[[["self"]],["bool"]]],[11,"neg","","",41,[[["self"]],["biguint"]]],[11,"neg","","Negate Sign value.",21,[[["self"]],["sign"]]],[11,"neg","","",40,[[["self"]],["bigint"]]],[11,"fmt","","",42,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result",["error"]]]],[11,"sub","","",40,[[["self"],["u32"]],["bigint"]]],[11,"sub","","",41,[[["self"],["u128"]],["biguint"]]],[11,"sub","","",40,[[["self"],["u8"]],["bigint"]]],[11,"sub","","",41,[[["self"],["u16"]],["biguint"]]],[11,"sub","","",40,[[["self"],["i16"]],["bigint"]]],[11,"sub","","",40,[[["self"],["u64"]],["bigint"]]],[11,"sub","","",40,[[["self"],["i64"]],["bigint"]]],[11,"sub","","",40,[[["self"],["u32"]],["bigint"]]],[11,"sub","","",40,[[["self"],["i32"]],["bigint"]]],[11,"sub","","",40,[[["self"],["i8"]],["bigint"]]],[11,"sub","","",41,[[["self"],["u8"]],["biguint"]]],[11,"sub","","",40,[[["self"],["isize"]],["bigint"]]],[11,"sub","","",40,[[["self"],["u8"]],["bigint"]]],[11,"sub","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"sub","","",40,[[["self"],["usize"]],["bigint"]]],[11,"sub","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"sub","","",40,[[["self"],["u64"]],["bigint"]]],[11,"sub","","",40,[[["self"],["i16"]],["bigint"]]],[11,"sub","","",41,[[["self"],["u64"]],["biguint"]]],[11,"sub","","",40,[[["self"],["u128"]],["bigint"]]],[11,"sub","","",40,[[["self"],["isize"]],["bigint"]]],[11,"sub","","",40,[[["self"],["i32"]],["bigint"]]],[11,"sub","","",40,[[["self"],["usize"]],["bigint"]]],[11,"sub","","",40,[[["self"],["u16"]],["bigint"]]],[11,"sub","","",40,[[["self"],["u128"]],["bigint"]]],[11,"sub","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"sub","","",41,[[["self"],["u32"]],["biguint"]]],[11,"sub","","",41,[[["self"],["u8"]],["biguint"]]],[11,"sub","","",41,[[["self"],["u16"]],["biguint"]]],[11,"sub","","",41,[[["self"],["u64"]],["biguint"]]],[11,"sub","","",40,[[["self"],["i128"]],["bigint"]]],[11,"sub","","",41,[[["self"],["u32"]],["biguint"]]],[11,"sub","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"sub","","",41,[[["self"],["usize"]],["biguint"]]],[11,"sub","","",40,[[["self"],["i64"]],["bigint"]]],[11,"sub","","",40,[[["self"],["i128"]],["bigint"]]],[11,"sub","","",41,[[["self"],["usize"]],["biguint"]]],[11,"sub","","",40,[[["self"],["i8"]],["bigint"]]],[11,"sub","","",40,[[["self"],["u16"]],["bigint"]]],[11,"sub","","",41,[[["self"],["u128"]],["biguint"]]],[11,"from_str","","",41,[[["str"]],["result",["biguint","parsebiginterror"]]]],[11,"from_str","","",40,[[["str"]],["result",["bigint","parsebiginterror"]]]],[11,"nth_root","","",41,[[["self"],["u32"]],["biguint"]]],[11,"sqrt","","",41,[[["self"]],["biguint"]]],[11,"cbrt","","",41,[[["self"]],["biguint"]]],[11,"nth_root","","",40,[[["self"],["u32"]],["bigint"]]],[11,"sqrt","","",40,[[["self"]],["bigint"]]],[11,"cbrt","","",40,[[["self"]],["bigint"]]],[11,"to_i64","","",40,[[["self"]],["option",["i64"]]]],[11,"to_i128","","",40,[[["self"]],["option",["i128"]]]],[11,"to_u64","","",40,[[["self"]],["option",["u64"]]]],[11,"to_u128","","",40,[[["self"]],["option",["u128"]]]],[11,"to_f32","","",40,[[["self"]],["option",["f32"]]]],[11,"to_f64","","",40,[[["self"]],["option",["f64"]]]],[11,"to_i64","","",41,[[["self"]],["option",["i64"]]]],[11,"to_i128","","",41,[[["self"]],["option",["i128"]]]],[11,"to_u64","","",41,[[["self"]],["option",["u64"]]]],[11,"to_u128","","",41,[[["self"]],["option",["u128"]]]],[11,"to_f32","","",41,[[["self"]],["option",["f32"]]]],[11,"to_f64","","",41,[[["self"]],["option",["f64"]]]],[11,"from","","",40,[[["biguint"]],["bigint"]]],[11,"from","","",40,[[["i128"]],["bigint"]]],[11,"from","","",40,[[["u64"]],["bigint"]]],[11,"from","","",40,[[["i64"]],["bigint"]]],[11,"from","","",40,[[["i32"]],["bigint"]]],[11,"from","","",41,[[["u64"]],["biguint"]]],[11,"from","","",40,[[["u8"]],["bigint"]]],[11,"from","","",41,[[["u128"]],["biguint"]]],[11,"from","","",40,[[["u128"]],["bigint"]]],[11,"from","","",40,[[["u16"]],["bigint"]]],[11,"from","","",40,[[["u32"]],["bigint"]]],[11,"from","","",40,[[["i16"]],["bigint"]]],[11,"from","","",40,[[["i8"]],["bigint"]]],[11,"from","","",41,[[["u32"]],["biguint"]]],[11,"from","","",41,[[["u16"]],["biguint"]]],[11,"from","","",40,[[["usize"]],["bigint"]]],[11,"from","","",40,[[["isize"]],["bigint"]]],[11,"from","","",41,[[["usize"]],["biguint"]]],[11,"from","","",41,[[["u8"]],["biguint"]]],[11,"mul","","",21,[[["self"],["sign"]],["sign"]]],[11,"mul","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"mul","","",40,[[["self"],["usize"]],["bigint"]]],[11,"mul","","",40,[[["self"],["u32"]],["bigint"]]],[11,"mul","","",40,[[["self"],["u8"]],["bigint"]]],[11,"mul","","",40,[[["self"],["u16"]],["bigint"]]],[11,"mul","","",41,[[["self"],["usize"]],["biguint"]]],[11,"mul","","",41,[[["self"],["u16"]],["biguint"]]],[11,"mul","","",40,[[["self"],["u64"]],["bigint"]]],[11,"mul","","",40,[[["self"],["u8"]],["bigint"]]],[11,"mul","","",41,[[["self"],["u8"]],["biguint"]]],[11,"mul","","",40,[[["self"],["u64"]],["bigint"]]],[11,"mul","","",41,[[["self"],["u32"]],["biguint"]]],[11,"mul","","",40,[[["self"],["usize"]],["bigint"]]],[11,"mul","","",41,[[["self"],["u64"]],["biguint"]]],[11,"mul","","",40,[[["self"],["u128"]],["bigint"]]],[11,"mul","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"mul","","",40,[[["self"],["i16"]],["bigint"]]],[11,"mul","","",41,[[["self"],["usize"]],["biguint"]]],[11,"mul","","",40,[[["self"],["i128"]],["bigint"]]],[11,"mul","","",40,[[["self"],["i16"]],["bigint"]]],[11,"mul","","",41,[[["self"],["u128"]],["biguint"]]],[11,"mul","","",40,[[["self"],["i32"]],["bigint"]]],[11,"mul","","",41,[[["self"],["u8"]],["biguint"]]],[11,"mul","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"mul","","",41,[[["self"],["u64"]],["biguint"]]],[11,"mul","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"mul","","",40,[[["self"],["u128"]],["bigint"]]],[11,"mul","","",40,[[["self"],["i64"]],["bigint"]]],[11,"mul","","",40,[[["self"],["i128"]],["bigint"]]],[11,"mul","","",40,[[["self"],["i32"]],["bigint"]]],[11,"mul","","",40,[[["self"],["i64"]],["bigint"]]],[11,"mul","","",40,[[["self"],["isize"]],["bigint"]]],[11,"mul","","",40,[[["self"],["u32"]],["bigint"]]],[11,"mul","","",41,[[["self"],["u16"]],["biguint"]]],[11,"mul","","",40,[[["self"],["i8"]],["bigint"]]],[11,"mul","","",41,[[["self"],["u32"]],["biguint"]]],[11,"mul","","",41,[[["self"],["u128"]],["biguint"]]],[11,"mul","","",40,[[["self"],["i8"]],["bigint"]]],[11,"mul","","",40,[[["self"],["u16"]],["bigint"]]],[11,"mul","","",40,[[["self"],["isize"]],["bigint"]]],[11,"rem_assign","","",40,N],[11,"rem_assign","","",40,N],[11,"rem_assign","","",40,N],[11,"rem_assign","","",40,N],[11,"rem_assign","","",40,N],[11,"rem_assign","","",40,N],[11,"rem_assign","","",40,N],[11,"rem_assign","","",41,N],[11,"rem_assign","","",40,N],[11,"rem_assign","","",40,N],[11,"rem_assign","","",40,N],[11,"rem_assign","","",40,N],[11,"rem_assign","","",41,N],[11,"rem_assign","","",41,N],[11,"rem_assign","","",40,N],[11,"rem_assign","","",41,N],[11,"rem_assign","","",41,N],[11,"rem_assign","","",41,N],[11,"rem_assign","","",41,N],[11,"rem_assign","","",40,N],[11,"rem_assign","","",40,N],[11,"rem_assign","","",41,N],[11,"sum","","",41,[[["i"]],["biguint"]]],[11,"sum","","",40,[[["i"]],["bigint"]]],[11,"eq","","",42,[[["self"],["parsebiginterror"]],["bool"]]],[11,"ne","","",42,[[["self"],["parsebiginterror"]],["bool"]]],[11,"eq","","",41,[[["self"],["biguint"]],["bool"]]],[11,"eq","","",40,[[["self"],["bigint"]],["bool"]]],[11,"eq","","",21,[[["self"],["sign"]],["bool"]]],[11,"rem","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"rem","","",41,[[["self"],["u64"]],["biguint"]]],[11,"rem","","",41,[[["self"],["u8"]],["biguint"]]],[11,"rem","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"rem","","",41,[[["self"],["usize"]],["biguint"]]],[11,"rem","","",40,[[["self"],["u8"]],["bigint"]]],[11,"rem","","",40,[[["self"],["i64"]],["bigint"]]],[11,"rem","","",40,[[["self"],["i128"]],["bigint"]]],[11,"rem","","",40,[[["self"],["usize"]],["bigint"]]],[11,"rem","","",41,[[["self"],["u16"]],["biguint"]]],[11,"rem","","",40,[[["self"],["u128"]],["bigint"]]],[11,"rem","","",41,[[["self"],["u32"]],["biguint"]]],[11,"rem","","",40,[[["self"],["i16"]],["bigint"]]],[11,"rem","","",41,[[["self"],["u8"]],["biguint"]]],[11,"rem","","",40,[[["self"],["u128"]],["bigint"]]],[11,"rem","","",40,[[["self"],["i32"]],["bigint"]]],[11,"rem","","",40,[[["self"],["isize"]],["bigint"]]],[11,"rem","","",41,[[["self"],["usize"]],["biguint"]]],[11,"rem","","",40,[[["self"],["i128"]],["bigint"]]],[11,"rem","","",40,[[["self"],["u32"]],["bigint"]]],[11,"rem","","",41,[[["self"],["u64"]],["biguint"]]],[11,"rem","","",40,[[["self"],["u32"]],["bigint"]]],[11,"rem","","",40,[[["self"],["u8"]],["bigint"]]],[11,"rem","","",40,[[["self"],["i64"]],["bigint"]]],[11,"rem","","",40,[[["self"],["u16"]],["bigint"]]],[11,"rem","","",41,[[["self"],["u16"]],["biguint"]]],[11,"rem","","",41,[[["self"],["u128"]],["biguint"]]],[11,"rem","","",40,[[["self"],["u64"]],["bigint"]]],[11,"rem","","",40,[[["self"],["u64"]],["bigint"]]],[11,"rem","","",41,[[["self"],["u128"]],["biguint"]]],[11,"rem","","",41,[[["self"],["biguint"]],["biguint"]]],[11,"rem","","",40,[[["self"],["i32"]],["bigint"]]],[11,"rem","","",40,[[["self"],["u16"]],["bigint"]]],[11,"rem","","",40,[[["self"],["i8"]],["bigint"]]],[11,"rem","","",40,[[["self"],["i8"]],["bigint"]]],[11,"rem","","",40,[[["self"],["isize"]],["bigint"]]],[11,"rem","","",40,[[["self"],["bigint"]],["bigint"]]],[11,"rem","","",40,[[["self"],["usize"]],["bigint"]]],[11,"rem","","",40,[[["self"],["i16"]],["bigint"]]],[11,"rem","","",41,[[["self"],["u32"]],["biguint"]]],[11,"next","num::integer","",44,[[["self"]],["option"]]],[11,"fmt","num::traits","",38,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",39,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",39,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","num::complex","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"zero","","",0,[[],["complex"]]],[11,"is_zero","","",0,[[["self"]],["bool"]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"to_usize","","",0,[[["self"]],["option",["usize"]]]],[11,"to_isize","","",0,[[["self"]],["option",["isize"]]]],[11,"to_u8","","",0,[[["self"]],["option",["u8"]]]],[11,"to_u16","","",0,[[["self"]],["option",["u16"]]]],[11,"to_u32","","",0,[[["self"]],["option",["u32"]]]],[11,"to_u64","","",0,[[["self"]],["option",["u64"]]]],[11,"to_i8","","",0,[[["self"]],["option",["i8"]]]],[11,"to_i16","","",0,[[["self"]],["option",["i16"]]]],[11,"to_i32","","",0,[[["self"]],["option",["i32"]]]],[11,"to_i64","","",0,[[["self"]],["option",["i64"]]]],[11,"to_u128","","",0,[[["self"]],["option",["u128"]]]],[11,"to_i128","","",0,[[["self"]],["option",["i128"]]]],[11,"to_f32","","",0,[[["self"]],["option",["f32"]]]],[11,"to_f64","","",0,[[["self"]],["option",["f64"]]]],[11,"from_usize","","",0,[[["usize"]],["option",["complex"]]]],[11,"from_isize","","",0,[[["isize"]],["option",["complex"]]]],[11,"from_u8","","",0,[[["u8"]],["option",["complex"]]]],[11,"from_u16","","",0,[[["u16"]],["option",["complex"]]]],[11,"from_u32","","",0,[[["u32"]],["option",["complex"]]]],[11,"from_u64","","",0,[[["u64"]],["option",["complex"]]]],[11,"from_i8","","",0,[[["i8"]],["option",["complex"]]]],[11,"from_i16","","",0,[[["i16"]],["option",["complex"]]]],[11,"from_i32","","",0,[[["i32"]],["option",["complex"]]]],[11,"from_i64","","",0,[[["i64"]],["option",["complex"]]]],[11,"from_u128","","",0,[[["u128"]],["option",["complex"]]]],[11,"from_i128","","",0,[[["i128"]],["option",["complex"]]]],[11,"from_f32","","",0,[[["f32"]],["option",["complex"]]]],[11,"from_f64","","",0,[[["f64"]],["option",["complex"]]]],[11,"default","","",0,[[],["complex"]]],[11,"add","","",0,[[["self"],["complex"]],["complex"]]],[11,"add","","",0,[[["self"],["t"]],["complex"]]],[11,"add","","",0,[[["self"],["t"]],["complex"]]],[11,"add","","",0,[[["self"],["complex"]],["complex"]]],[11,"description","","",43,[[["self"]],["str"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"mul_assign","","",0,N],[11,"mul_assign","","",0,N],[11,"mul_assign","","",0,N],[11,"mul_assign","","",0,N],[11,"add_assign","","",0,N],[11,"add_assign","","",0,N],[11,"add_assign","","",0,N],[11,"add_assign","","",0,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"clone","","",0,[[["self"]],["complex"]]],[11,"sum","","",0,[[["i"]],["complex"]]],[11,"sum","","",0,[[["i"]],["complex"]]],[11,"eq","","",0,[[["self"],["complex"]],["bool"]]],[11,"ne","","",0,[[["self"],["complex"]],["bool"]]],[11,"eq","","",43,[[["self"],["parsecomplexerror"]],["bool"]]],[11,"ne","","",43,[[["self"],["parsecomplexerror"]],["bool"]]],[11,"rem","","",0,[[["self"],["t"]],["complex"]]],[11,"rem","","",0,[[["self"],["complex"]],["complex"]]],[11,"rem","","",0,[[["self"],["complex"]],["complex"]]],[11,"rem","","",0,[[["self"],["t"]],["complex"]]],[11,"rem_assign","","",0,N],[11,"rem_assign","","",0,N],[11,"rem_assign","","",0,N],[11,"rem_assign","","",0,N],[11,"mul","","",0,[[["self"],["t"]],["complex"]]],[11,"mul","","",0,[[["self"],["t"]],["complex"]]],[11,"mul","","",0,[[["self"],["complex"]],["complex"]]],[11,"mul","","",0,[[["self"],["complex"]],["complex"]]],[11,"from","","",0,[[["t"]],["complex"]]],[11,"from","","",0,[[["t"]],["complex"]]],[11,"from_str_radix","","Parses `a +/- bi`; `ai +/- b`; `a`; or `bi` where `a` and `b` are of type `T`",0,[[["str"],["u32"]],["result",["complex"]]]],[11,"inv","","",0,[[["self"]],["complex"]]],[11,"sub","","",0,[[["self"],["t"]],["complex"]]],[11,"sub","","",0,[[["self"],["complex"]],["complex"]]],[11,"sub","","",0,[[["self"],["t"]],["complex"]]],[11,"sub","","",0,[[["self"],["complex"]],["complex"]]],[11,"from_str","","Parses `a +/- bi`; `ai +/- b`; `a`; or `bi` where `a` and `b` are of type `T`",0,[[["str"]],["result",["complex"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"as_","","",0,[[["self"]],["u"]]],[11,"neg","","",0,[[["self"]],["complex"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result",["error"]]]],[11,"product","","",0,[[["i"]],["complex"]]],[11,"product","","",0,[[["i"]],["complex"]]],[11,"div_assign","","",0,N],[11,"div_assign","","",0,N],[11,"div_assign","","",0,N],[11,"div_assign","","",0,N],[11,"div","","",0,[[["self"],["t"]],["complex"]]],[11,"div","","",0,[[["self"],["complex"]],["complex"]]],[11,"div","","",0,[[["self"],["t"]],["complex"]]],[11,"div","","",0,[[["self"],["complex"]],["complex"]]],[11,"sub_assign","","",0,N],[11,"sub_assign","","",0,N],[11,"sub_assign","","",0,N],[11,"sub_assign","","",0,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"from","","",0,[[["u"]],["option",["complex"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"hash","","",0,N],[11,"one","","",0,[[],["complex"]]],[11,"is_one","","",0,[[["self"]],["bool"]]],[11,"next","num::iter","",45,[[["self"]],["option"]]],[11,"size_hint","","",45,N],[11,"next","","",48,[[["self"]],["option"]]],[11,"next","","",46,[[["self"]],["option"]]],[11,"size_hint","","",46,N],[11,"next","","",47,[[["self"]],["option"]]],[11,"next_back","","",46,[[["self"]],["option"]]],[11,"next_back","","",45,[[["self"]],["option"]]],[11,"clone","","",48,[[["self"]],["rangestepinclusive"]]],[11,"clone","","",46,[[["self"]],["rangeinclusive"]]],[11,"clone","","",47,[[["self"]],["rangestep"]]],[11,"clone","","",45,[[["self"]],["range"]]],[11,"from_i64","num::rational","",49,[[["i64"]],["option",["ratio"]]]],[11,"from_i128","","",49,[[["i128"]],["option",["ratio"]]]],[11,"from_u64","","",49,[[["u64"]],["option",["ratio"]]]],[11,"from_u128","","",49,[[["u128"]],["option",["ratio"]]]],[11,"from_f32","","",49,[[["f32"]],["option",["ratio"]]]],[11,"from_f64","","",49,[[["f64"]],["option",["ratio"]]]],[11,"from_i64","","",49,[[["i64"]],["option",["ratio"]]]],[11,"from_i128","","",49,[[["i128"]],["option",["ratio"]]]],[11,"from_u64","","",49,[[["u64"]],["option",["ratio"]]]],[11,"from_u128","","",49,[[["u128"]],["option",["ratio"]]]],[11,"from_f32","","",49,[[["f32"]],["option",["ratio"]]]],[11,"from_f64","","",49,[[["f64"]],["option",["ratio"]]]],[11,"from_i64","","",49,[[["i64"]],["option",["ratio"]]]],[11,"from_i128","","",49,[[["i128"]],["option",["ratio"]]]],[11,"from_u64","","",49,[[["u64"]],["option",["ratio"]]]],[11,"from_u128","","",49,[[["u128"]],["option",["ratio"]]]],[11,"from_f32","","",49,[[["f32"]],["option",["ratio"]]]],[11,"from_f64","","",49,[[["f64"]],["option",["ratio"]]]],[11,"from_i64","","",49,[[["i64"]],["option",["ratio"]]]],[11,"from_i128","","",49,[[["i128"]],["option",["ratio"]]]],[11,"from_u64","","",49,[[["u64"]],["option",["ratio"]]]],[11,"from_u128","","",49,[[["u128"]],["option",["ratio"]]]],[11,"from_f32","","",49,[[["f32"]],["option",["ratio"]]]],[11,"from_f64","","",49,[[["f64"]],["option",["ratio"]]]],[11,"from_i64","","",49,[[["i64"]],["option",["ratio"]]]],[11,"from_i128","","",49,[[["i128"]],["option",["ratio"]]]],[11,"from_u64","","",49,[[["u64"]],["option",["ratio"]]]],[11,"from_u128","","",49,[[["u128"]],["option",["ratio"]]]],[11,"from_f32","","",49,[[["f32"]],["option",["ratio"]]]],[11,"from_f64","","",49,[[["f64"]],["option",["ratio"]]]],[11,"from_i64","","",49,[[["i64"]],["option",["ratio"]]]],[11,"from_i128","","",49,[[["i128"]],["option",["ratio"]]]],[11,"from_u64","","",49,[[["u64"]],["option",["ratio"]]]],[11,"from_u128","","",49,[[["u128"]],["option",["ratio"]]]],[11,"from_f32","","",49,[[["f32"]],["option",["ratio"]]]],[11,"from_f64","","",49,[[["f64"]],["option",["ratio"]]]],[11,"from_i64","","",49,[[["i64"]],["option",["ratio"]]]],[11,"from_i128","","",49,[[["i128"]],["option",["ratio"]]]],[11,"from_u64","","",49,[[["u64"]],["option",["ratio"]]]],[11,"from_u128","","",49,[[["u128"]],["option",["ratio"]]]],[11,"from_f32","","",49,[[["f32"]],["option",["ratio"]]]],[11,"from_f64","","",49,[[["f64"]],["option",["ratio"]]]],[11,"from_i64","","",49,[[["i64"]],["option",["ratio"]]]],[11,"from_i128","","",49,[[["i128"]],["option",["ratio"]]]],[11,"from_u64","","",49,[[["u64"]],["option",["ratio"]]]],[11,"from_u128","","",49,[[["u128"]],["option",["ratio"]]]],[11,"from_f32","","",49,[[["f32"]],["option",["ratio"]]]],[11,"from_f64","","",49,[[["f64"]],["option",["ratio"]]]],[11,"from_i64","","",49,[[["i64"]],["option",["ratio"]]]],[11,"from_i128","","",49,[[["i128"]],["option",["ratio"]]]],[11,"from_u64","","",49,[[["u64"]],["option",["ratio"]]]],[11,"from_u128","","",49,[[["u128"]],["option",["ratio"]]]],[11,"from_f32","","",49,[[["f32"]],["option",["ratio"]]]],[11,"from_f64","","",49,[[["f64"]],["option",["ratio"]]]],[11,"from_i64","","",49,[[["i64"]],["option",["ratio"]]]],[11,"from_i128","","",49,[[["i128"]],["option",["ratio"]]]],[11,"from_u64","","",49,[[["u64"]],["option",["ratio"]]]],[11,"from_u128","","",49,[[["u128"]],["option",["ratio"]]]],[11,"from_f32","","",49,[[["f32"]],["option",["ratio"]]]],[11,"from_f64","","",49,[[["f64"]],["option",["ratio"]]]],[11,"from_i64","","",49,[[["i64"]],["option",["ratio"]]]],[11,"from_i128","","",49,[[["i128"]],["option",["ratio"]]]],[11,"from_u64","","",49,[[["u64"]],["option",["ratio"]]]],[11,"from_u128","","",49,[[["u128"]],["option",["ratio"]]]],[11,"from_f32","","",49,[[["f32"]],["option",["ratio"]]]],[11,"from_f64","","",49,[[["f64"]],["option",["ratio"]]]],[11,"from_i64","","",49,[[["i64"]],["option",["ratio"]]]],[11,"from_i128","","",49,[[["i128"]],["option",["ratio"]]]],[11,"from_u64","","",49,[[["u64"]],["option",["ratio"]]]],[11,"from_u128","","",49,[[["u128"]],["option",["ratio"]]]],[11,"from_f32","","",49,[[["f32"]],["option",["ratio"]]]],[11,"from_f64","","",49,[[["f64"]],["option",["ratio"]]]],[11,"from_i64","","",49,[[["i64"]],["option",["ratio"]]]],[11,"from_i128","","",49,[[["i128"]],["option",["ratio"]]]],[11,"from_u64","","",49,[[["u64"]],["option",["ratio"]]]],[11,"from_u128","","",49,[[["u128"]],["option",["ratio"]]]],[11,"from_f32","","",49,[[["f32"]],["option",["ratio"]]]],[11,"from_f64","","",49,[[["f64"]],["option",["ratio"]]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",50,[[["self"],["formatter"]],["result",["error"]]]],[11,"checked_mul","","",49,[[["self"],["ratio"]],["option",["ratio"]]]],[11,"checked_div","","",49,[[["self"],["ratio"]],["option",["ratio"]]]],[11,"into","","",49,N],[11,"zero","","",49,[[],["ratio"]]],[11,"is_zero","","",49,[[["self"]],["bool"]]],[11,"one","","",49,[[],["ratio"]]],[11,"is_one","","",49,[[["self"]],["bool"]]],[11,"add","","",49,[[["self"],["t"]],["ratio"]]],[11,"add","","",49,[[["self"],["t"]],["ratio"]]],[11,"add","","",49,[[["self"],["ratio"]],["ratio"]]],[11,"add","","",49,[[["self"],["ratio"]],["ratio"]]],[11,"cmp","","",49,[[["self"],["ratio"]],["ordering"]]],[11,"mul_assign","","",49,N],[11,"mul_assign","","",49,N],[11,"mul_assign","","",49,N],[11,"mul_assign","","",49,N],[11,"add_assign","","",49,N],[11,"add_assign","","",49,N],[11,"add_assign","","",49,N],[11,"add_assign","","",49,N],[11,"clone","","",49,[[["self"]],["ratio"]]],[11,"clone","","",50,[[["self"]],["parseratioerror"]]],[11,"sum","","",49,[[["i"]],["ratio"]]],[11,"sum","","",49,[[["i"]],["ratio"]]],[11,"eq","","",49,[[["self"],["ratio"]],["bool"]]],[11,"eq","","",50,[[["self"],["parseratioerror"]],["bool"]]],[11,"ne","","",50,[[["self"],["parseratioerror"]],["bool"]]],[11,"rem","","",49,[[["self"],["ratio"]],["ratio"]]],[11,"rem","","",49,[[["self"],["t"]],["ratio"]]],[11,"rem","","",49,[[["self"],["t"]],["ratio"]]],[11,"rem","","",49,[[["self"],["ratio"]],["ratio"]]],[11,"rem_assign","","",49,N],[11,"rem_assign","","",49,N],[11,"rem_assign","","",49,N],[11,"rem_assign","","",49,N],[11,"mul","","",49,[[["self"],["t"]],["ratio"]]],[11,"mul","","",49,[[["self"],["ratio"]],["ratio"]]],[11,"mul","","",49,[[["self"],["ratio"]],["ratio"]]],[11,"mul","","",49,[[["self"],["t"]],["ratio"]]],[11,"from","","",49,N],[11,"from","","",49,[[["t"]],["ratio"]]],[11,"description","","",50,[[["self"]],["str"]]],[11,"sub","","",49,[[["self"],["ratio"]],["ratio"]]],[11,"sub","","",49,[[["self"],["ratio"]],["ratio"]]],[11,"sub","","",49,[[["self"],["t"]],["ratio"]]],[11,"sub","","",49,[[["self"],["t"]],["ratio"]]],[11,"from_str","","Parses `numer/denom` or just `numer`.",49,[[["str"]],["result",["ratio","parseratioerror"]]]],[11,"neg","","",49,[[["self"]],["ratio"]]],[11,"inv","","",49,[[["self"]],["ratio"]]],[11,"fmt","","Renders as `numer/denom`. If denom=1, renders as numer.",49,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",50,[[["self"],["formatter"]],["result",["error"]]]],[11,"from_str_radix","","Parses `numer/denom` where the numbers are in base `radix`.",49,[[["str"],["u32"]],["result",["ratio","parseratioerror"]]]],[11,"pow","","",49,[[["self"],["isize"]],["ratio"]]],[11,"pow","","",49,[[["self"],["u64"]],["ratio"]]],[11,"pow","","",49,[[["self"],["i32"]],["ratio"]]],[11,"pow","","",49,[[["self"],["u8"]],["ratio"]]],[11,"pow","","",49,[[["self"],["i8"]],["ratio"]]],[11,"pow","","",49,[[["self"],["i64"]],["ratio"]]],[11,"pow","","",49,[[["self"],["u16"]],["ratio"]]],[11,"pow","","",49,[[["self"],["u32"]],["ratio"]]],[11,"pow","","",49,[[["self"],["i8"]],["ratio"]]],[11,"pow","","",49,[[["self"],["i64"]],["ratio"]]],[11,"pow","","",49,[[["self"],["i16"]],["ratio"]]],[11,"pow","","",49,[[["self"],["usize"]],["ratio"]]],[11,"pow","","",49,[[["self"],["i32"]],["ratio"]]],[11,"pow","","",49,[[["self"],["isize"]],["ratio"]]],[11,"pow","","",49,[[["self"],["u16"]],["ratio"]]],[11,"pow","","",49,[[["self"],["usize"]],["ratio"]]],[11,"pow","","",49,[[["self"],["u8"]],["ratio"]]],[11,"pow","","",49,[[["self"],["i16"]],["ratio"]]],[11,"pow","","",49,[[["self"],["u32"]],["ratio"]]],[11,"pow","","",49,[[["self"],["u64"]],["ratio"]]],[11,"product","","",49,[[["i"]],["ratio"]]],[11,"product","","",49,[[["i"]],["ratio"]]],[11,"checked_add","","",49,[[["self"],["ratio"]],["option",["ratio"]]]],[11,"abs","","",49,[[["self"]],["ratio"]]],[11,"abs_sub","","",49,[[["self"],["ratio"]],["ratio"]]],[11,"signum","","",49,[[["self"]],["ratio"]]],[11,"is_positive","","",49,[[["self"]],["bool"]]],[11,"is_negative","","",49,[[["self"]],["bool"]]],[11,"checked_sub","","",49,[[["self"],["ratio"]],["option",["ratio"]]]],[11,"div_assign","","",49,N],[11,"div_assign","","",49,N],[11,"div_assign","","",49,N],[11,"div_assign","","",49,N],[11,"div","","",49,[[["self"],["ratio"]],["ratio"]]],[11,"div","","",49,[[["self"],["t"]],["ratio"]]],[11,"div","","",49,[[["self"],["t"]],["ratio"]]],[11,"div","","",49,[[["self"],["ratio"]],["ratio"]]],[11,"partial_cmp","","",49,[[["self"],["ratio"]],["option",["ordering"]]]],[11,"sub_assign","","",49,N],[11,"sub_assign","","",49,N],[11,"sub_assign","","",49,N],[11,"sub_assign","","",49,N],[11,"hash","","",49,N],[11,"new","num::bigint","Creates and initializes a BigInt.",40,[[["sign"],["vec",["u32"]]],["bigint"]]],[11,"from_biguint","","Creates and initializes a `BigInt`.",40,[[["sign"],["biguint"]],["bigint"]]],[11,"from_slice","","Creates and initializes a `BigInt`.",40,N],[11,"assign_from_slice","","Reinitializes a `BigInt`.",40,N],[11,"from_bytes_be","","Creates and initializes a `BigInt`.",40,N],[11,"from_bytes_le","","Creates and initializes a `BigInt`.",40,N],[11,"from_signed_bytes_be","","Creates and initializes a `BigInt` from an array of bytes in two's complement binary representation.",40,N],[11,"from_signed_bytes_le","","Creates and initializes a `BigInt` from an array of bytes in two's complement.",40,N],[11,"parse_bytes","","Creates and initializes a `BigInt`.",40,N],[11,"from_radix_be","","Creates and initializes a `BigInt`. Each u8 of the input slice is interpreted as one digit of the number and must therefore be less than `radix`.",40,N],[11,"from_radix_le","","Creates and initializes a `BigInt`. Each u8 of the input slice is interpreted as one digit of the number and must therefore be less than `radix`.",40,N],[11,"to_bytes_be","","Returns the sign and the byte representation of the `BigInt` in big-endian byte order.",40,N],[11,"to_bytes_le","","Returns the sign and the byte representation of the `BigInt` in little-endian byte order.",40,N],[11,"to_signed_bytes_be","","Returns the two's complement byte representation of the `BigInt` in big-endian byte order.",40,[[["self"]],["vec",["u8"]]]],[11,"to_signed_bytes_le","","Returns the two's complement byte representation of the `BigInt` in little-endian byte order.",40,[[["self"]],["vec",["u8"]]]],[11,"to_str_radix","","Returns the integer formatted as a string in the given radix. `radix` must be in the range `2...36`.",40,[[["self"],["u32"]],["string"]]],[11,"to_radix_be","","Returns the integer in the requested base in big-endian digit order. The output is not given in a human readable alphabet but as a zero based u8 number. `radix` must be in the range `2...256`.",40,N],[11,"to_radix_le","","Returns the integer in the requested base in little-endian digit order. The output is not given in a human readable alphabet but as a zero based u8 number. `radix` must be in the range `2...256`.",40,N],[11,"sign","","Returns the sign of the `BigInt` as a `Sign`.",40,[[["self"]],["sign"]]],[11,"bits","","Determines the fewest bits necessary to express the `BigInt`, not including the sign.",40,[[["self"]],["usize"]]],[11,"to_biguint","","Converts this `BigInt` into a `BigUint`, if it's not negative.",40,[[["self"]],["option",["biguint"]]]],[11,"checked_add","","",40,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_sub","","",40,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_mul","","",40,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_div","","",40,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"modpow","","Returns `(self ^ exponent) mod modulus`",40,[[["self"],["bigint"],["bigint"]],["bigint"]]],[11,"sqrt","","Returns the truncated principal square root of `self` -- see Roots::sqrt.",40,[[["self"]],["bigint"]]],[11,"cbrt","","Returns the truncated principal cube root of `self` -- see Roots::cbrt.",40,[[["self"]],["bigint"]]],[11,"nth_root","","Returns the truncated principal `n`th root of `self` -- See Roots::nth_root.",40,[[["self"],["u32"]],["bigint"]]],[11,"new","","Creates and initializes a `BigUint`.",41,[[["vec",["u32"]]],["biguint"]]],[11,"from_slice","","Creates and initializes a `BigUint`.",41,N],[11,"assign_from_slice","","Assign a value to a `BigUint`.",41,N],[11,"from_bytes_be","","Creates and initializes a `BigUint`.",41,N],[11,"from_bytes_le","","Creates and initializes a `BigUint`.",41,N],[11,"parse_bytes","","Creates and initializes a `BigUint`. The input slice must contain ascii/utf8 characters in [0-9a-zA-Z]. `radix` must be in the range `2...36`.",41,N],[11,"from_radix_be","","Creates and initializes a `BigUint`. Each u8 of the input slice is interpreted as one digit of the number and must therefore be less than `radix`.",41,N],[11,"from_radix_le","","Creates and initializes a `BigUint`. Each u8 of the input slice is interpreted as one digit of the number and must therefore be less than `radix`.",41,N],[11,"to_bytes_be","","Returns the byte representation of the `BigUint` in big-endian byte order.",41,[[["self"]],["vec",["u8"]]]],[11,"to_bytes_le","","Returns the byte representation of the `BigUint` in little-endian byte order.",41,[[["self"]],["vec",["u8"]]]],[11,"to_str_radix","","Returns the integer formatted as a string in the given radix. `radix` must be in the range `2...36`.",41,[[["self"],["u32"]],["string"]]],[11,"to_radix_be","","Returns the integer in the requested base in big-endian digit order. The output is not given in a human readable alphabet but as a zero based u8 number. `radix` must be in the range `2...256`.",41,[[["self"],["u32"]],["vec",["u8"]]]],[11,"to_radix_le","","Returns the integer in the requested base in little-endian digit order. The output is not given in a human readable alphabet but as a zero based u8 number. `radix` must be in the range `2...256`.",41,[[["self"],["u32"]],["vec",["u8"]]]],[11,"bits","","Determines the fewest bits necessary to express the `BigUint`.",41,[[["self"]],["usize"]]],[11,"modpow","","Returns `(self ^ exponent) % modulus`.",41,[[["self"],["biguint"],["biguint"]],["biguint"]]],[11,"sqrt","","Returns the truncated principal square root of `self` -- see Roots::sqrt",41,[[["self"]],["biguint"]]],[11,"cbrt","","Returns the truncated principal cube root of `self` -- see Roots::cbrt.",41,[[["self"]],["biguint"]]],[11,"nth_root","","Returns the truncated principal `n`th root of `self` -- see Roots::nth_root.",41,[[["self"],["u32"]],["biguint"]]],[11,"new","num::complex","Create a new Complex",0,[[["t"],["t"]],["complex"]]],[11,"i","","Returns imaginary unit",0,[[],["complex"]]],[11,"norm_sqr","","Returns the square of the norm (since `T` doesn't necessarily have a sqrt function), i.e. `re^2 + im^2`.",0,[[["self"]],["t"]]],[11,"scale","","Multiplies `self` by the scalar `t`.",0,[[["self"],["t"]],["complex"]]],[11,"unscale","","Divides `self` by the scalar `t`.",0,[[["self"],["t"]],["complex"]]],[11,"conj","","Returns the complex conjugate. i.e. `re - i im`",0,[[["self"]],["complex"]]],[11,"inv","","Returns `1/self`",0,[[["self"]],["complex"]]],[11,"norm","","Calculate |self|",0,[[["self"]],["t"]]],[11,"arg","","Calculate the principal Arg of self.",0,[[["self"]],["t"]]],[11,"to_polar","","Convert to polar form (r, theta), such that `self = r * exp(i * theta)`",0,N],[11,"from_polar","","Convert a polar representation into a complex number.",0,[[["t"],["t"]],["complex"]]],[11,"exp","","Computes `e^(self)`, where `e` is the base of the natural logarithm.",0,[[["self"]],["complex"]]],[11,"ln","","Computes the principal value of natural logarithm of `self`.",0,[[["self"]],["complex"]]],[11,"sqrt","","Computes the principal value of the square root of `self`.",0,[[["self"]],["complex"]]],[11,"powf","","Raises `self` to a floating point power.",0,[[["self"],["t"]],["complex"]]],[11,"log","","Returns the logarithm of `self` with respect to an arbitrary base.",0,[[["self"],["t"]],["complex"]]],[11,"powc","","Raises `self` to a complex power.",0,[[["self"],["complex"]],["complex"]]],[11,"expf","","Raises a floating point number to the complex power `self`.",0,[[["self"],["t"]],["complex"]]],[11,"sin","","Computes the sine of `self`.",0,[[["self"]],["complex"]]],[11,"cos","","Computes the cosine of `self`.",0,[[["self"]],["complex"]]],[11,"tan","","Computes the tangent of `self`.",0,[[["self"]],["complex"]]],[11,"asin","","Computes the principal value of the inverse sine of `self`.",0,[[["self"]],["complex"]]],[11,"acos","","Computes the principal value of the inverse cosine of `self`.",0,[[["self"]],["complex"]]],[11,"atan","","Computes the principal value of the inverse tangent of `self`.",0,[[["self"]],["complex"]]],[11,"sinh","","Computes the hyperbolic sine of `self`.",0,[[["self"]],["complex"]]],[11,"cosh","","Computes the hyperbolic cosine of `self`.",0,[[["self"]],["complex"]]],[11,"tanh","","Computes the hyperbolic tangent of `self`.",0,[[["self"]],["complex"]]],[11,"asinh","","Computes the principal value of inverse hyperbolic sine of `self`.",0,[[["self"]],["complex"]]],[11,"acosh","","Computes the principal value of inverse hyperbolic cosine of `self`.",0,[[["self"]],["complex"]]],[11,"atanh","","Computes the principal value of inverse hyperbolic tangent of `self`.",0,[[["self"]],["complex"]]],[11,"is_nan","","Checks if the given complex number is NaN",0,[[["self"]],["bool"]]],[11,"is_infinite","","Checks if the given complex number is infinite",0,[[["self"]],["bool"]]],[11,"is_finite","","Checks if the given complex number is finite",0,[[["self"]],["bool"]]],[11,"is_normal","","Checks if the given complex number is normal",0,[[["self"]],["bool"]]],[11,"new","num::integer","For a given n, iterate over all binomial coefficients binomial(n, k), for k=0...n.",44,[[["t"]],["iterbinomial"]]],[11,"new","num::rational","Creates a new `Ratio`. Fails if `denom` is zero.",49,[[["t"],["t"]],["ratio"]]],[11,"from_integer","","Creates a `Ratio` representing the integer `t`.",49,[[["t"]],["ratio"]]],[11,"new_raw","","Creates a `Ratio` without checking for `denom == 0` or reducing.",49,[[["t"],["t"]],["ratio"]]],[11,"to_integer","","Converts to an integer, rounding towards zero.",49,[[["self"]],["t"]]],[11,"numer","","Gets an immutable reference to the numerator.",49,[[["self"]],["t"]]],[11,"denom","","Gets an immutable reference to the denominator.",49,[[["self"]],["t"]]],[11,"is_integer","","Returns true if the rational number is an integer (denominator is 1).",49,[[["self"]],["bool"]]],[11,"reduced","","Returns a reduced copy of self.",49,[[["self"]],["ratio"]]],[11,"recip","","Returns the reciprocal.",49,[[["self"]],["ratio"]]],[11,"floor","","Rounds towards minus infinity.",49,[[["self"]],["ratio"]]],[11,"ceil","","Rounds towards plus infinity.",49,[[["self"]],["ratio"]]],[11,"round","","Rounds to the nearest integer. Rounds half-way cases away from zero.",49,[[["self"]],["ratio"]]],[11,"trunc","","Rounds towards zero.",49,[[["self"]],["ratio"]]],[11,"fract","","Returns the fractional part of a number, with division rounded towards zero.",49,[[["self"]],["ratio"]]],[11,"pow","","Raises the `Ratio` to the power of an exponent.",49,[[["self"],["i32"]],["ratio"]]],[11,"from_float","","Converts a float into a rational number.",49,[[["t"]],["option",["ratio"]]]],[11,"approximate_float","","",49,[[["f"]],["option",["ratio"]]]]],"paths":[[3,"Complex"],[8,"Integer"],[8,"Num"],[8,"Zero"],[8,"One"],[8,"Signed"],[8,"Bounded"],[8,"Saturating"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"PrimInt"],[8,"ToPrimitive"],[8,"FromPrimitive"],[8,"NumCast"],[8,"AsPrimitive"],[8,"Pow"],[8,"Float"],[8,"ToBigInt"],[8,"ToBigUint"],[4,"Sign"],[8,"Roots"],[8,"FloatCore"],[8,"FloatConst"],[8,"CheckedRem"],[8,"CheckedNeg"],[8,"CheckedShl"],[8,"CheckedShr"],[8,"Inv"],[8,"MulAdd"],[8,"MulAddAssign"],[8,"WrappingAdd"],[8,"WrappingSub"],[8,"WrappingMul"],[8,"WrappingShl"],[8,"WrappingShr"],[8,"Real"],[4,"FloatErrorKind"],[3,"ParseFloatError"],[3,"BigInt"],[3,"BigUint"],[3,"ParseBigIntError"],[3,"ParseComplexError"],[3,"IterBinomial"],[3,"Range"],[3,"RangeInclusive"],[3,"RangeStep"],[3,"RangeStepInclusive"],[3,"Ratio"],[3,"ParseRatioError"]]};
searchIndex["num_bigint"]={"doc":"A Big integer (signed version: `BigInt`, unsigned version: `BigUint`).","items":[[3,"ParseBigIntError","num_bigint","",N,N],[3,"BigUint","","A big unsigned integer type.",N,N],[3,"BigInt","","A big signed integer type.",N,N],[4,"Sign","","A Sign is a `BigInt`'s composing element.",N,N],[13,"Minus","","",0,N],[13,"NoSign","","",0,N],[13,"Plus","","",0,N],[11,"new","","Creates and initializes a BigInt.",1,[[["sign"],["vec",["u32"]]],["bigint"]]],[11,"from_biguint","","Creates and initializes a `BigInt`.",1,[[["sign"],["biguint"]],["bigint"]]],[11,"from_slice","","Creates and initializes a `BigInt`.",1,N],[11,"assign_from_slice","","Reinitializes a `BigInt`.",1,N],[11,"from_bytes_be","","Creates and initializes a `BigInt`.",1,N],[11,"from_bytes_le","","Creates and initializes a `BigInt`.",1,N],[11,"from_signed_bytes_be","","Creates and initializes a `BigInt` from an array of bytes in two's complement binary representation.",1,N],[11,"from_signed_bytes_le","","Creates and initializes a `BigInt` from an array of bytes in two's complement.",1,N],[11,"parse_bytes","","Creates and initializes a `BigInt`.",1,N],[11,"from_radix_be","","Creates and initializes a `BigInt`. Each u8 of the input slice is interpreted as one digit of the number and must therefore be less than `radix`.",1,N],[11,"from_radix_le","","Creates and initializes a `BigInt`. Each u8 of the input slice is interpreted as one digit of the number and must therefore be less than `radix`.",1,N],[11,"to_bytes_be","","Returns the sign and the byte representation of the `BigInt` in big-endian byte order.",1,N],[11,"to_bytes_le","","Returns the sign and the byte representation of the `BigInt` in little-endian byte order.",1,N],[11,"to_signed_bytes_be","","Returns the two's complement byte representation of the `BigInt` in big-endian byte order.",1,[[["self"]],["vec",["u8"]]]],[11,"to_signed_bytes_le","","Returns the two's complement byte representation of the `BigInt` in little-endian byte order.",1,[[["self"]],["vec",["u8"]]]],[11,"to_str_radix","","Returns the integer formatted as a string in the given radix. `radix` must be in the range `2...36`.",1,[[["self"],["u32"]],["string"]]],[11,"to_radix_be","","Returns the integer in the requested base in big-endian digit order. The output is not given in a human readable alphabet but as a zero based u8 number. `radix` must be in the range `2...256`.",1,N],[11,"to_radix_le","","Returns the integer in the requested base in little-endian digit order. The output is not given in a human readable alphabet but as a zero based u8 number. `radix` must be in the range `2...256`.",1,N],[11,"sign","","Returns the sign of the `BigInt` as a `Sign`.",1,[[["self"]],["sign"]]],[11,"bits","","Determines the fewest bits necessary to express the `BigInt`, not including the sign.",1,[[["self"]],["usize"]]],[11,"to_biguint","","Converts this `BigInt` into a `BigUint`, if it's not negative.",1,[[["self"]],["option",["biguint"]]]],[11,"checked_add","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_sub","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_mul","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_div","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"modpow","","Returns `(self ^ exponent) mod modulus`",1,[[["self"],["self"],["self"]],["self"]]],[11,"sqrt","","Returns the truncated principal square root of `self` -- see Roots::sqrt.",1,[[["self"]],["self"]]],[11,"cbrt","","Returns the truncated principal cube root of `self` -- see Roots::cbrt.",1,[[["self"]],["self"]]],[11,"nth_root","","Returns the truncated principal `n`th root of `self` -- See Roots::nth_root.",1,[[["self"],["u32"]],["self"]]],[11,"new","","Creates and initializes a `BigUint`.",2,[[["vec",["u32"]]],["biguint"]]],[11,"from_slice","","Creates and initializes a `BigUint`.",2,N],[11,"assign_from_slice","","Assign a value to a `BigUint`.",2,N],[11,"from_bytes_be","","Creates and initializes a `BigUint`.",2,N],[11,"from_bytes_le","","Creates and initializes a `BigUint`.",2,N],[11,"parse_bytes","","Creates and initializes a `BigUint`. The input slice must contain ascii/utf8 characters in [0-9a-zA-Z]. `radix` must be in the range `2...36`.",2,N],[11,"from_radix_be","","Creates and initializes a `BigUint`. Each u8 of the input slice is interpreted as one digit of the number and must therefore be less than `radix`.",2,N],[11,"from_radix_le","","Creates and initializes a `BigUint`. Each u8 of the input slice is interpreted as one digit of the number and must therefore be less than `radix`.",2,N],[11,"to_bytes_be","","Returns the byte representation of the `BigUint` in big-endian byte order.",2,[[["self"]],["vec",["u8"]]]],[11,"to_bytes_le","","Returns the byte representation of the `BigUint` in little-endian byte order.",2,[[["self"]],["vec",["u8"]]]],[11,"to_str_radix","","Returns the integer formatted as a string in the given radix. `radix` must be in the range `2...36`.",2,[[["self"],["u32"]],["string"]]],[11,"to_radix_be","","Returns the integer in the requested base in big-endian digit order. The output is not given in a human readable alphabet but as a zero based u8 number. `radix` must be in the range `2...256`.",2,[[["self"],["u32"]],["vec",["u8"]]]],[11,"to_radix_le","","Returns the integer in the requested base in little-endian digit order. The output is not given in a human readable alphabet but as a zero based u8 number. `radix` must be in the range `2...256`.",2,[[["self"],["u32"]],["vec",["u8"]]]],[11,"bits","","Determines the fewest bits necessary to express the `BigUint`.",2,[[["self"]],["usize"]]],[11,"modpow","","Returns `(self ^ exponent) % modulus`.",2,[[["self"],["self"],["self"]],["self"]]],[11,"sqrt","","Returns the truncated principal square root of `self` -- see Roots::sqrt",2,[[["self"]],["self"]]],[11,"cbrt","","Returns the truncated principal cube root of `self` -- see Roots::cbrt.",2,[[["self"]],["self"]]],[11,"nth_root","","Returns the truncated principal `n`th root of `self` -- see Roots::nth_root.",2,[[["self"],["u32"]],["self"]]],[8,"ToBigUint","","A generic trait for converting a value to a `BigUint`.",N,N],[10,"to_biguint","","Converts the value of `self` to a `BigUint`.",3,[[["self"]],["option",["biguint"]]]],[8,"ToBigInt","","A generic trait for converting a value to a `BigInt`.",N,N],[10,"to_bigint","","Converts the value of `self` to a `BigInt`.",4,[[["self"]],["option",["bigint"]]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"to_string","","",5,[[["self"]],["string"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_bigint","","",1,[[["self"]],["option",["bigint"]]]],[11,"to_bigint","","",2,[[["self"]],["option",["bigint"]]]],[11,"to_biguint","","",1,[[["self"]],["option",["biguint"]]]],[11,"to_biguint","","",2,[[["self"]],["option",["biguint"]]]],[11,"default","","",1,[[],["bigint"]]],[11,"default","","",2,[[],["biguint"]]],[11,"eq","","",0,[[["self"],["sign"]],["bool"]]],[11,"eq","","",1,[[["self"],["bigint"]],["bool"]]],[11,"eq","","",2,[[["self"],["biguint"]],["bool"]]],[11,"eq","","",5,[[["self"],["parsebiginterror"]],["bool"]]],[11,"ne","","",5,[[["self"],["parsebiginterror"]],["bool"]]],[11,"from","","",1,[[["i64"]],["self"]]],[11,"from","","",1,[[["i128"]],["self"]]],[11,"from","","",1,[[["i8"]],["self"]]],[11,"from","","",1,[[["i16"]],["self"]]],[11,"from","","",1,[[["i32"]],["self"]]],[11,"from","","",1,[[["isize"]],["self"]]],[11,"from","","",1,[[["u64"]],["self"]]],[11,"from","","",1,[[["u128"]],["self"]]],[11,"from","","",1,[[["u8"]],["self"]]],[11,"from","","",1,[[["u16"]],["self"]]],[11,"from","","",1,[[["u32"]],["self"]]],[11,"from","","",1,[[["usize"]],["self"]]],[11,"from","","",1,[[["biguint"]],["self"]]],[11,"from","","",2,[[["u64"]],["self"]]],[11,"from","","",2,[[["u128"]],["self"]]],[11,"from","","",2,[[["u8"]],["self"]]],[11,"from","","",2,[[["u16"]],["self"]]],[11,"from","","",2,[[["u32"]],["self"]]],[11,"from","","",2,[[["usize"]],["self"]]],[11,"clone","","",0,[[["self"]],["sign"]]],[11,"clone","","",1,[[["self"]],["bigint"]]],[11,"clone","","",2,[[["self"]],["biguint"]]],[11,"clone","","",5,[[["self"]],["parsebiginterror"]]],[11,"cmp","","",0,[[["self"],["sign"]],["ordering"]]],[11,"cmp","","",1,[[["self"],["bigint"]],["ordering"]]],[11,"cmp","","",2,[[["self"],["biguint"]],["ordering"]]],[11,"partial_cmp","","",0,[[["self"],["sign"]],["option",["ordering"]]]],[11,"partial_cmp","","",1,[[["self"],["bigint"]],["option",["ordering"]]]],[11,"partial_cmp","","",2,[[["self"],["biguint"]],["option",["ordering"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"from_str","","",1,[[["str"]],["result",["bigint","parsebiginterror"]]]],[11,"from_str","","",2,[[["str"]],["result",["biguint","parsebiginterror"]]]],[11,"add","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"add","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"add","","",1,[[["self"],["u8"]],["bigint"]]],[11,"add","","",1,[[["self"],["u8"]],["bigint"]]],[11,"add","","",1,[[["self"],["u16"]],["bigint"]]],[11,"add","","",1,[[["self"],["u16"]],["bigint"]]],[11,"add","","",1,[[["self"],["usize"]],["bigint"]]],[11,"add","","",1,[[["self"],["usize"]],["bigint"]]],[11,"add","","",1,[[["self"],["i8"]],["bigint"]]],[11,"add","","",1,[[["self"],["i8"]],["bigint"]]],[11,"add","","",1,[[["self"],["i16"]],["bigint"]]],[11,"add","","",1,[[["self"],["i16"]],["bigint"]]],[11,"add","","",1,[[["self"],["isize"]],["bigint"]]],[11,"add","","",1,[[["self"],["isize"]],["bigint"]]],[11,"add","","",1,[[["self"],["u32"]],["bigint"]]],[11,"add","","",1,[[["self"],["u64"]],["bigint"]]],[11,"add","","",1,[[["self"],["u128"]],["bigint"]]],[11,"add","","",1,[[["self"],["u32"]],["bigint"]]],[11,"add","","",1,[[["self"],["u64"]],["bigint"]]],[11,"add","","",1,[[["self"],["u128"]],["bigint"]]],[11,"add","","",1,[[["self"],["i32"]],["bigint"]]],[11,"add","","",1,[[["self"],["i64"]],["bigint"]]],[11,"add","","",1,[[["self"],["i128"]],["bigint"]]],[11,"add","","",1,[[["self"],["i32"]],["bigint"]]],[11,"add","","",1,[[["self"],["i64"]],["bigint"]]],[11,"add","","",1,[[["self"],["i128"]],["bigint"]]],[11,"add","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"add","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"add","","",2,[[["self"],["u8"]],["biguint"]]],[11,"add","","",2,[[["self"],["u8"]],["biguint"]]],[11,"add","","",2,[[["self"],["u16"]],["biguint"]]],[11,"add","","",2,[[["self"],["u16"]],["biguint"]]],[11,"add","","",2,[[["self"],["usize"]],["biguint"]]],[11,"add","","",2,[[["self"],["usize"]],["biguint"]]],[11,"add","","",2,[[["self"],["u32"]],["biguint"]]],[11,"add","","",2,[[["self"],["u64"]],["biguint"]]],[11,"add","","",2,[[["self"],["u128"]],["biguint"]]],[11,"add","","",2,[[["self"],["u32"]],["biguint"]]],[11,"add","","",2,[[["self"],["u64"]],["biguint"]]],[11,"add","","",2,[[["self"],["u128"]],["biguint"]]],[11,"sub","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"sub","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u8"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u8"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u16"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u16"]],["bigint"]]],[11,"sub","","",1,[[["self"],["usize"]],["bigint"]]],[11,"sub","","",1,[[["self"],["usize"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i8"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i8"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i16"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i16"]],["bigint"]]],[11,"sub","","",1,[[["self"],["isize"]],["bigint"]]],[11,"sub","","",1,[[["self"],["isize"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u32"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u64"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u128"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u32"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u64"]],["bigint"]]],[11,"sub","","",1,[[["self"],["u128"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i32"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i64"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i128"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i32"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i64"]],["bigint"]]],[11,"sub","","",1,[[["self"],["i128"]],["bigint"]]],[11,"sub","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"sub","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u8"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u8"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u16"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u16"]],["biguint"]]],[11,"sub","","",2,[[["self"],["usize"]],["biguint"]]],[11,"sub","","",2,[[["self"],["usize"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u32"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u64"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u128"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u32"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u64"]],["biguint"]]],[11,"sub","","",2,[[["self"],["u128"]],["biguint"]]],[11,"mul","","",0,[[["self"],["sign"]],["sign"]]],[11,"mul","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"mul","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u8"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u8"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u16"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u16"]],["bigint"]]],[11,"mul","","",1,[[["self"],["usize"]],["bigint"]]],[11,"mul","","",1,[[["self"],["usize"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i8"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i8"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i16"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i16"]],["bigint"]]],[11,"mul","","",1,[[["self"],["isize"]],["bigint"]]],[11,"mul","","",1,[[["self"],["isize"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u32"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u64"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u128"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u32"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u64"]],["bigint"]]],[11,"mul","","",1,[[["self"],["u128"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i32"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i64"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i128"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i32"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i64"]],["bigint"]]],[11,"mul","","",1,[[["self"],["i128"]],["bigint"]]],[11,"mul","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"mul","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u8"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u8"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u16"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u16"]],["biguint"]]],[11,"mul","","",2,[[["self"],["usize"]],["biguint"]]],[11,"mul","","",2,[[["self"],["usize"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u32"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u64"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u128"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u32"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u64"]],["biguint"]]],[11,"mul","","",2,[[["self"],["u128"]],["biguint"]]],[11,"div","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"div","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"div","","",1,[[["self"],["u8"]],["bigint"]]],[11,"div","","",1,[[["self"],["u8"]],["bigint"]]],[11,"div","","",1,[[["self"],["u16"]],["bigint"]]],[11,"div","","",1,[[["self"],["u16"]],["bigint"]]],[11,"div","","",1,[[["self"],["usize"]],["bigint"]]],[11,"div","","",1,[[["self"],["usize"]],["bigint"]]],[11,"div","","",1,[[["self"],["i8"]],["bigint"]]],[11,"div","","",1,[[["self"],["i8"]],["bigint"]]],[11,"div","","",1,[[["self"],["i16"]],["bigint"]]],[11,"div","","",1,[[["self"],["i16"]],["bigint"]]],[11,"div","","",1,[[["self"],["isize"]],["bigint"]]],[11,"div","","",1,[[["self"],["isize"]],["bigint"]]],[11,"div","","",1,[[["self"],["u32"]],["bigint"]]],[11,"div","","",1,[[["self"],["u64"]],["bigint"]]],[11,"div","","",1,[[["self"],["u128"]],["bigint"]]],[11,"div","","",1,[[["self"],["u32"]],["bigint"]]],[11,"div","","",1,[[["self"],["u64"]],["bigint"]]],[11,"div","","",1,[[["self"],["u128"]],["bigint"]]],[11,"div","","",1,[[["self"],["i32"]],["bigint"]]],[11,"div","","",1,[[["self"],["i64"]],["bigint"]]],[11,"div","","",1,[[["self"],["i128"]],["bigint"]]],[11,"div","","",1,[[["self"],["i32"]],["bigint"]]],[11,"div","","",1,[[["self"],["i64"]],["bigint"]]],[11,"div","","",1,[[["self"],["i128"]],["bigint"]]],[11,"div","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"div","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"div","","",2,[[["self"],["u8"]],["biguint"]]],[11,"div","","",2,[[["self"],["u8"]],["biguint"]]],[11,"div","","",2,[[["self"],["u16"]],["biguint"]]],[11,"div","","",2,[[["self"],["u16"]],["biguint"]]],[11,"div","","",2,[[["self"],["usize"]],["biguint"]]],[11,"div","","",2,[[["self"],["usize"]],["biguint"]]],[11,"div","","",2,[[["self"],["u32"]],["biguint"]]],[11,"div","","",2,[[["self"],["u64"]],["biguint"]]],[11,"div","","",2,[[["self"],["u128"]],["biguint"]]],[11,"div","","",2,[[["self"],["u32"]],["biguint"]]],[11,"div","","",2,[[["self"],["u64"]],["biguint"]]],[11,"div","","",2,[[["self"],["u128"]],["biguint"]]],[11,"rem","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"rem","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u8"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u8"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u16"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u16"]],["bigint"]]],[11,"rem","","",1,[[["self"],["usize"]],["bigint"]]],[11,"rem","","",1,[[["self"],["usize"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i8"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i8"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i16"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i16"]],["bigint"]]],[11,"rem","","",1,[[["self"],["isize"]],["bigint"]]],[11,"rem","","",1,[[["self"],["isize"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u32"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u64"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u128"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u32"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u64"]],["bigint"]]],[11,"rem","","",1,[[["self"],["u128"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i32"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i64"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i128"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i32"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i64"]],["bigint"]]],[11,"rem","","",1,[[["self"],["i128"]],["bigint"]]],[11,"rem","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"rem","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u8"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u8"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u16"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u16"]],["biguint"]]],[11,"rem","","",2,[[["self"],["usize"]],["biguint"]]],[11,"rem","","",2,[[["self"],["usize"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u32"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u64"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u128"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u32"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u64"]],["biguint"]]],[11,"rem","","",2,[[["self"],["u128"]],["biguint"]]],[11,"neg","","Negate Sign value.",0,[[["self"]],["sign"]]],[11,"neg","","",1,[[["self"]],["bigint"]]],[11,"neg","","",2,[[["self"]],["biguint"]]],[11,"add_assign","","",1,[[["self"],["bigint"]]]],[11,"add_assign","","",1,[[["self"],["bigint"]]]],[11,"add_assign","","",1,[[["self"],["u8"]]]],[11,"add_assign","","",1,[[["self"],["u16"]]]],[11,"add_assign","","",1,[[["self"],["usize"]]]],[11,"add_assign","","",1,[[["self"],["i8"]]]],[11,"add_assign","","",1,[[["self"],["i16"]]]],[11,"add_assign","","",1,[[["self"],["isize"]]]],[11,"add_assign","","",1,[[["self"],["u32"]]]],[11,"add_assign","","",1,[[["self"],["u64"]]]],[11,"add_assign","","",1,[[["self"],["u128"]]]],[11,"add_assign","","",1,[[["self"],["i32"]]]],[11,"add_assign","","",1,[[["self"],["i64"]]]],[11,"add_assign","","",1,[[["self"],["i128"]]]],[11,"add_assign","","",2,[[["self"],["biguint"]]]],[11,"add_assign","","",2,[[["self"],["biguint"]]]],[11,"add_assign","","",2,[[["self"],["u8"]]]],[11,"add_assign","","",2,[[["self"],["u16"]]]],[11,"add_assign","","",2,[[["self"],["usize"]]]],[11,"add_assign","","",2,[[["self"],["u32"]]]],[11,"add_assign","","",2,[[["self"],["u64"]]]],[11,"add_assign","","",2,[[["self"],["u128"]]]],[11,"sub_assign","","",1,[[["self"],["bigint"]]]],[11,"sub_assign","","",1,[[["self"],["bigint"]]]],[11,"sub_assign","","",1,[[["self"],["u8"]]]],[11,"sub_assign","","",1,[[["self"],["u16"]]]],[11,"sub_assign","","",1,[[["self"],["usize"]]]],[11,"sub_assign","","",1,[[["self"],["i8"]]]],[11,"sub_assign","","",1,[[["self"],["i16"]]]],[11,"sub_assign","","",1,[[["self"],["isize"]]]],[11,"sub_assign","","",1,[[["self"],["u32"]]]],[11,"sub_assign","","",1,[[["self"],["u64"]]]],[11,"sub_assign","","",1,[[["self"],["u128"]]]],[11,"sub_assign","","",1,[[["self"],["i32"]]]],[11,"sub_assign","","",1,[[["self"],["i64"]]]],[11,"sub_assign","","",1,[[["self"],["i128"]]]],[11,"sub_assign","","",2,[[["self"],["biguint"]]]],[11,"sub_assign","","",2,[[["self"],["biguint"]]]],[11,"sub_assign","","",2,[[["self"],["u8"]]]],[11,"sub_assign","","",2,[[["self"],["u16"]]]],[11,"sub_assign","","",2,[[["self"],["usize"]]]],[11,"sub_assign","","",2,[[["self"],["u32"]]]],[11,"sub_assign","","",2,[[["self"],["u64"]]]],[11,"sub_assign","","",2,[[["self"],["u128"]]]],[11,"mul_assign","","",1,[[["self"],["bigint"]]]],[11,"mul_assign","","",1,[[["self"],["bigint"]]]],[11,"mul_assign","","",1,[[["self"],["u8"]]]],[11,"mul_assign","","",1,[[["self"],["u16"]]]],[11,"mul_assign","","",1,[[["self"],["usize"]]]],[11,"mul_assign","","",1,[[["self"],["i8"]]]],[11,"mul_assign","","",1,[[["self"],["i16"]]]],[11,"mul_assign","","",1,[[["self"],["isize"]]]],[11,"mul_assign","","",1,[[["self"],["u32"]]]],[11,"mul_assign","","",1,[[["self"],["u64"]]]],[11,"mul_assign","","",1,[[["self"],["u128"]]]],[11,"mul_assign","","",1,[[["self"],["i32"]]]],[11,"mul_assign","","",1,[[["self"],["i64"]]]],[11,"mul_assign","","",1,[[["self"],["i128"]]]],[11,"mul_assign","","",2,[[["self"],["biguint"]]]],[11,"mul_assign","","",2,[[["self"],["biguint"]]]],[11,"mul_assign","","",2,[[["self"],["u8"]]]],[11,"mul_assign","","",2,[[["self"],["u16"]]]],[11,"mul_assign","","",2,[[["self"],["usize"]]]],[11,"mul_assign","","",2,[[["self"],["u32"]]]],[11,"mul_assign","","",2,[[["self"],["u64"]]]],[11,"mul_assign","","",2,[[["self"],["u128"]]]],[11,"div_assign","","",1,[[["self"],["bigint"]]]],[11,"div_assign","","",1,[[["self"],["bigint"]]]],[11,"div_assign","","",1,[[["self"],["u8"]]]],[11,"div_assign","","",1,[[["self"],["u16"]]]],[11,"div_assign","","",1,[[["self"],["usize"]]]],[11,"div_assign","","",1,[[["self"],["i8"]]]],[11,"div_assign","","",1,[[["self"],["i16"]]]],[11,"div_assign","","",1,[[["self"],["isize"]]]],[11,"div_assign","","",1,[[["self"],["u32"]]]],[11,"div_assign","","",1,[[["self"],["u64"]]]],[11,"div_assign","","",1,[[["self"],["u128"]]]],[11,"div_assign","","",1,[[["self"],["i32"]]]],[11,"div_assign","","",1,[[["self"],["i64"]]]],[11,"div_assign","","",1,[[["self"],["i128"]]]],[11,"div_assign","","",2,[[["self"],["biguint"]]]],[11,"div_assign","","",2,[[["self"],["biguint"]]]],[11,"div_assign","","",2,[[["self"],["u8"]]]],[11,"div_assign","","",2,[[["self"],["u16"]]]],[11,"div_assign","","",2,[[["self"],["usize"]]]],[11,"div_assign","","",2,[[["self"],["u32"]]]],[11,"div_assign","","",2,[[["self"],["u64"]]]],[11,"div_assign","","",2,[[["self"],["u128"]]]],[11,"rem_assign","","",1,[[["self"],["bigint"]]]],[11,"rem_assign","","",1,[[["self"],["bigint"]]]],[11,"rem_assign","","",1,[[["self"],["u8"]]]],[11,"rem_assign","","",1,[[["self"],["u16"]]]],[11,"rem_assign","","",1,[[["self"],["usize"]]]],[11,"rem_assign","","",1,[[["self"],["i8"]]]],[11,"rem_assign","","",1,[[["self"],["i16"]]]],[11,"rem_assign","","",1,[[["self"],["isize"]]]],[11,"rem_assign","","",1,[[["self"],["u32"]]]],[11,"rem_assign","","",1,[[["self"],["u64"]]]],[11,"rem_assign","","",1,[[["self"],["u128"]]]],[11,"rem_assign","","",1,[[["self"],["i32"]]]],[11,"rem_assign","","",1,[[["self"],["i64"]]]],[11,"rem_assign","","",1,[[["self"],["i128"]]]],[11,"rem_assign","","",2,[[["self"],["biguint"]]]],[11,"rem_assign","","",2,[[["self"],["biguint"]]]],[11,"rem_assign","","",2,[[["self"],["u8"]]]],[11,"rem_assign","","",2,[[["self"],["u16"]]]],[11,"rem_assign","","",2,[[["self"],["usize"]]]],[11,"rem_assign","","",2,[[["self"],["u32"]]]],[11,"rem_assign","","",2,[[["self"],["u64"]]]],[11,"rem_assign","","",2,[[["self"],["u128"]]]],[11,"not","","",1,[[["self"]],["bigint"]]],[11,"bitand","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"bitand","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"bitand","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"bitand","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"bitor","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"bitor","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"bitor","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"bitor","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"bitxor","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"bitxor","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"bitxor","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"bitxor","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"shl","","",1,[[["self"],["usize"]],["bigint"]]],[11,"shl","","",2,[[["self"],["usize"]],["biguint"]]],[11,"shr","","",1,[[["self"],["usize"]],["bigint"]]],[11,"shr","","",2,[[["self"],["usize"]],["biguint"]]],[11,"bitand_assign","","",1,[[["self"],["bigint"]]]],[11,"bitand_assign","","",1,[[["self"],["bigint"]]]],[11,"bitand_assign","","",2,[[["self"],["biguint"]]]],[11,"bitand_assign","","",2,[[["self"],["biguint"]]]],[11,"bitor_assign","","",1,[[["self"],["bigint"]]]],[11,"bitor_assign","","",1,[[["self"],["bigint"]]]],[11,"bitor_assign","","",2,[[["self"],["biguint"]]]],[11,"bitor_assign","","",2,[[["self"],["biguint"]]]],[11,"bitxor_assign","","",1,[[["self"],["bigint"]]]],[11,"bitxor_assign","","",1,[[["self"],["bigint"]]]],[11,"bitxor_assign","","",2,[[["self"],["biguint"]]]],[11,"bitxor_assign","","",2,[[["self"],["biguint"]]]],[11,"shl_assign","","",1,[[["self"],["usize"]]]],[11,"shl_assign","","",2,[[["self"],["usize"]]]],[11,"shr_assign","","",1,[[["self"],["usize"]]]],[11,"shr_assign","","",2,[[["self"],["usize"]]]],[11,"hash","","",0,N],[11,"hash","","",1,N],[11,"hash","","",2,N],[11,"sum","","",1,[[["i"]],["self"]]],[11,"sum","","",2,[[["i"]],["self"]]],[11,"product","","",1,[[["i"]],["self"]]],[11,"product","","",2,[[["i"]],["self"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"description","","",5,[[["self"]],["str"]]],[11,"nth_root","","",1,[[["self"],["u32"]],["self"]]],[11,"sqrt","","",1,[[["self"]],["self"]]],[11,"cbrt","","",1,[[["self"]],["self"]]],[11,"nth_root","","",2,[[["self"],["u32"]],["self"]]],[11,"sqrt","","",2,[[["self"]],["self"]]],[11,"cbrt","","",2,[[["self"]],["self"]]],[11,"div_rem","","",1,N],[11,"div_floor","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"mod_floor","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"div_mod_floor","","",1,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",1,[[["self"],["bigint"]],["bigint"]]],[11,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",1,[[["self"],["bigint"]],["bigint"]]],[11,"divides","","Deprecated, use `is_multiple_of` instead.",1,[[["self"],["bigint"]],["bool"]]],[11,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",1,[[["self"],["bigint"]],["bool"]]],[11,"is_even","","Returns `true` if the number is divisible by `2`.",1,[[["self"]],["bool"]]],[11,"is_odd","","Returns `true` if the number is not divisible by `2`.",1,[[["self"]],["bool"]]],[11,"div_rem","","",2,N],[11,"div_floor","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"mod_floor","","",2,[[["self"],["biguint"]],["biguint"]]],[11,"div_mod_floor","","",2,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",2,[[["self"],["self"]],["self"]]],[11,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",2,[[["self"],["biguint"]],["biguint"]]],[11,"divides","","Deprecated, use `is_multiple_of` instead.",2,[[["self"],["biguint"]],["bool"]]],[11,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",2,[[["self"],["biguint"]],["bool"]]],[11,"is_even","","Returns `true` if the number is divisible by `2`.",2,[[["self"]],["bool"]]],[11,"is_odd","","Returns `true` if the number is not divisible by `2`.",2,[[["self"]],["bool"]]],[11,"to_i64","","",1,[[["self"]],["option",["i64"]]]],[11,"to_i128","","",1,[[["self"]],["option",["i128"]]]],[11,"to_u64","","",1,[[["self"]],["option",["u64"]]]],[11,"to_u128","","",1,[[["self"]],["option",["u128"]]]],[11,"to_f32","","",1,[[["self"]],["option",["f32"]]]],[11,"to_f64","","",1,[[["self"]],["option",["f64"]]]],[11,"to_i64","","",2,[[["self"]],["option",["i64"]]]],[11,"to_i128","","",2,[[["self"]],["option",["i128"]]]],[11,"to_u64","","",2,[[["self"]],["option",["u64"]]]],[11,"to_u128","","",2,[[["self"]],["option",["u128"]]]],[11,"to_f32","","",2,[[["self"]],["option",["f32"]]]],[11,"to_f64","","",2,[[["self"]],["option",["f64"]]]],[11,"from_i64","","",1,[[["i64"]],["option",["bigint"]]]],[11,"from_i128","","",1,[[["i128"]],["option",["bigint"]]]],[11,"from_u64","","",1,[[["u64"]],["option",["bigint"]]]],[11,"from_u128","","",1,[[["u128"]],["option",["bigint"]]]],[11,"from_f64","","",1,[[["f64"]],["option",["bigint"]]]],[11,"from_i64","","",2,[[["i64"]],["option",["biguint"]]]],[11,"from_i128","","",2,[[["i128"]],["option",["biguint"]]]],[11,"from_u64","","",2,[[["u64"]],["option",["biguint"]]]],[11,"from_u128","","",2,[[["u128"]],["option",["biguint"]]]],[11,"from_f64","","",2,[[["f64"]],["option",["biguint"]]]],[11,"from_str_radix","","Creates and initializes a BigInt.",1,[[["str"],["u32"]],["result",["bigint","parsebiginterror"]]]],[11,"from_str_radix","","Creates and initializes a `BigUint`.",2,[[["str"],["u32"]],["result",["biguint","parsebiginterror"]]]],[11,"zero","","",1,[[],["bigint"]]],[11,"is_zero","","",1,[[["self"]],["bool"]]],[11,"zero","","",2,[[],["biguint"]]],[11,"is_zero","","",2,[[["self"]],["bool"]]],[11,"one","","",1,[[],["bigint"]]],[11,"is_one","","",1,[[["self"]],["bool"]]],[11,"one","","",2,[[],["biguint"]]],[11,"is_one","","",2,[[["self"]],["bool"]]],[11,"checked_div","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_div","","",2,[[["self"],["biguint"]],["option",["biguint"]]]],[11,"checked_sub","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_sub","","",2,[[["self"],["biguint"]],["option",["biguint"]]]],[11,"checked_mul","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_mul","","",2,[[["self"],["biguint"]],["option",["biguint"]]]],[11,"checked_add","","",1,[[["self"],["bigint"]],["option",["bigint"]]]],[11,"checked_add","","",2,[[["self"],["biguint"]],["option",["biguint"]]]],[11,"abs","","",1,[[["self"]],["bigint"]]],[11,"abs_sub","","",1,[[["self"],["bigint"]],["bigint"]]],[11,"signum","","",1,[[["self"]],["bigint"]]],[11,"is_positive","","",1,[[["self"]],["bool"]]],[11,"is_negative","","",1,[[["self"]],["bool"]]]],"paths":[[4,"Sign"],[3,"BigInt"],[3,"BigUint"],[8,"ToBigUint"],[8,"ToBigInt"],[3,"ParseBigIntError"]]};
searchIndex["num_complex"]={"doc":"Complex numbers.","items":[[3,"Complex","num_complex","A complex number in Cartesian form.",N,N],[12,"re","","Real portion of the complex number",0,N],[12,"im","","Imaginary portion of the complex number",0,N],[3,"ParseComplexError","","",N,N],[6,"Complex32","","",N,N],[6,"Complex64","","",N,N],[11,"new","","Create a new Complex",0,[[["t"],["t"]],["complex"]]],[11,"i","","Returns imaginary unit",0,[[],["complex"]]],[11,"norm_sqr","","Returns the square of the norm (since `T` doesn't necessarily have a sqrt function), i.e. `re^2 + im^2`.",0,[[["self"]],["t"]]],[11,"scale","","Multiplies `self` by the scalar `t`.",0,[[["self"],["t"]],["complex"]]],[11,"unscale","","Divides `self` by the scalar `t`.",0,[[["self"],["t"]],["complex"]]],[11,"conj","","Returns the complex conjugate. i.e. `re - i im`",0,[[["self"]],["complex"]]],[11,"inv","","Returns `1/self`",0,[[["self"]],["complex"]]],[11,"norm","","Calculate |self|",0,[[["self"]],["t"]]],[11,"arg","","Calculate the principal Arg of self.",0,[[["self"]],["t"]]],[11,"to_polar","","Convert to polar form (r, theta), such that `self = r * exp(i * theta)`",0,N],[11,"from_polar","","Convert a polar representation into a complex number.",0,[[["t"],["t"]],["complex"]]],[11,"exp","","Computes `e^(self)`, where `e` is the base of the natural logarithm.",0,[[["self"]],["complex"]]],[11,"ln","","Computes the principal value of natural logarithm of `self`.",0,[[["self"]],["complex"]]],[11,"sqrt","","Computes the principal value of the square root of `self`.",0,[[["self"]],["complex"]]],[11,"powf","","Raises `self` to a floating point power.",0,[[["self"],["t"]],["complex"]]],[11,"log","","Returns the logarithm of `self` with respect to an arbitrary base.",0,[[["self"],["t"]],["complex"]]],[11,"powc","","Raises `self` to a complex power.",0,[[["self"],["complex"]],["complex"]]],[11,"expf","","Raises a floating point number to the complex power `self`.",0,[[["self"],["t"]],["complex"]]],[11,"sin","","Computes the sine of `self`.",0,[[["self"]],["complex"]]],[11,"cos","","Computes the cosine of `self`.",0,[[["self"]],["complex"]]],[11,"tan","","Computes the tangent of `self`.",0,[[["self"]],["complex"]]],[11,"asin","","Computes the principal value of the inverse sine of `self`.",0,[[["self"]],["complex"]]],[11,"acos","","Computes the principal value of the inverse cosine of `self`.",0,[[["self"]],["complex"]]],[11,"atan","","Computes the principal value of the inverse tangent of `self`.",0,[[["self"]],["complex"]]],[11,"sinh","","Computes the hyperbolic sine of `self`.",0,[[["self"]],["complex"]]],[11,"cosh","","Computes the hyperbolic cosine of `self`.",0,[[["self"]],["complex"]]],[11,"tanh","","Computes the hyperbolic tangent of `self`.",0,[[["self"]],["complex"]]],[11,"asinh","","Computes the principal value of inverse hyperbolic sine of `self`.",0,[[["self"]],["complex"]]],[11,"acosh","","Computes the principal value of inverse hyperbolic cosine of `self`.",0,[[["self"]],["complex"]]],[11,"atanh","","Computes the principal value of inverse hyperbolic tangent of `self`.",0,[[["self"]],["complex"]]],[11,"is_nan","","Checks if the given complex number is NaN",0,[[["self"]],["bool"]]],[11,"is_infinite","","Checks if the given complex number is infinite",0,[[["self"]],["bool"]]],[11,"is_finite","","Checks if the given complex number is finite",0,[[["self"]],["bool"]]],[11,"is_normal","","Checks if the given complex number is normal",0,[[["self"]],["bool"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"clone","","",0,[[["self"]],["complex"]]],[11,"eq","","",0,[[["self"],["complex"]],["bool"]]],[11,"ne","","",0,[[["self"],["complex"]],["bool"]]],[11,"eq","","",1,[[["self"],["parsecomplexerror"]],["bool"]]],[11,"ne","","",1,[[["self"],["parsecomplexerror"]],["bool"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"from_str","","Parses `a +/- bi`; `ai +/- b`; `a`; or `bi` where `a` and `b` are of type `T`",0,[[["str"]],["result"]]],[11,"add","","",0,[[["self"],["complex"]],["complex"]]],[11,"add","","",0,[[["self"],["complex"]],["complex"]]],[11,"add","","",0,[[["self"],["t"]],["complex"]]],[11,"add","","",0,[[["self"],["t"]],["complex"]]],[11,"sub","","",0,[[["self"],["complex"]],["complex"]]],[11,"sub","","",0,[[["self"],["complex"]],["complex"]]],[11,"sub","","",0,[[["self"],["t"]],["complex"]]],[11,"sub","","",0,[[["self"],["t"]],["complex"]]],[11,"mul","","",0,[[["self"],["complex"]],["complex"]]],[11,"mul","","",0,[[["self"],["complex"]],["complex"]]],[11,"mul","","",0,[[["self"],["t"]],["complex"]]],[11,"mul","","",0,[[["self"],["t"]],["complex"]]],[11,"div","","",0,[[["self"],["complex"]],["complex"]]],[11,"div","","",0,[[["self"],["complex"]],["complex"]]],[11,"div","","",0,[[["self"],["t"]],["complex"]]],[11,"div","","",0,[[["self"],["t"]],["complex"]]],[11,"rem","","",0,[[["self"],["complex"]],["complex"]]],[11,"rem","","",0,[[["self"],["complex"]],["self"]]],[11,"rem","","",0,[[["self"],["t"]],["complex"]]],[11,"rem","","",0,[[["self"],["t"]],["complex"]]],[11,"neg","","",0,[[["self"]],["complex"]]],[11,"add_assign","","",0,[[["self"],["complex"]]]],[11,"add_assign","","",0,[[["self"],["t"]]]],[11,"add_assign","","",0,[[["self"],["complex"]]]],[11,"add_assign","","",0,[[["self"],["t"]]]],[11,"sub_assign","","",0,[[["self"],["complex"]]]],[11,"sub_assign","","",0,[[["self"],["t"]]]],[11,"sub_assign","","",0,[[["self"],["complex"]]]],[11,"sub_assign","","",0,[[["self"],["t"]]]],[11,"mul_assign","","",0,[[["self"],["complex"]]]],[11,"mul_assign","","",0,[[["self"],["t"]]]],[11,"mul_assign","","",0,[[["self"],["complex"]]]],[11,"mul_assign","","",0,[[["self"],["t"]]]],[11,"div_assign","","",0,[[["self"],["complex"]]]],[11,"div_assign","","",0,[[["self"],["t"]]]],[11,"div_assign","","",0,[[["self"],["complex"]]]],[11,"div_assign","","",0,[[["self"],["t"]]]],[11,"rem_assign","","",0,[[["self"],["complex"]]]],[11,"rem_assign","","",0,[[["self"],["t"]]]],[11,"rem_assign","","",0,[[["self"],["complex"]]]],[11,"rem_assign","","",0,[[["self"],["t"]]]],[11,"hash","","",0,N],[11,"sum","","",0,[[["i"]],["self"]]],[11,"sum","","",0,[[["i"]],["self"]]],[11,"product","","",0,[[["i"]],["self"]]],[11,"product","","",0,[[["i"]],["self"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"from","","",0,[[["t"]],["complex"]]],[11,"from","","",0,[[["t"]],["complex"]]],[11,"default","","",0,[[],["complex"]]],[11,"description","","",1,[[["self"]],["str"]]],[11,"to_usize","","",0,[[["self"]],["option",["usize"]]]],[11,"to_isize","","",0,[[["self"]],["option",["isize"]]]],[11,"to_u8","","",0,[[["self"]],["option",["u8"]]]],[11,"to_u16","","",0,[[["self"]],["option",["u16"]]]],[11,"to_u32","","",0,[[["self"]],["option",["u32"]]]],[11,"to_u64","","",0,[[["self"]],["option",["u64"]]]],[11,"to_i8","","",0,[[["self"]],["option",["i8"]]]],[11,"to_i16","","",0,[[["self"]],["option",["i16"]]]],[11,"to_i32","","",0,[[["self"]],["option",["i32"]]]],[11,"to_i64","","",0,[[["self"]],["option",["i64"]]]],[11,"to_u128","","",0,[[["self"]],["option",["u128"]]]],[11,"to_i128","","",0,[[["self"]],["option",["i128"]]]],[11,"to_f32","","",0,[[["self"]],["option",["f32"]]]],[11,"to_f64","","",0,[[["self"]],["option",["f64"]]]],[11,"from_usize","","",0,[[["usize"]],["option"]]],[11,"from_isize","","",0,[[["isize"]],["option"]]],[11,"from_u8","","",0,[[["u8"]],["option"]]],[11,"from_u16","","",0,[[["u16"]],["option"]]],[11,"from_u32","","",0,[[["u32"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_i8","","",0,[[["i8"]],["option"]]],[11,"from_i16","","",0,[[["i16"]],["option"]]],[11,"from_i32","","",0,[[["i32"]],["option"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"from","","",0,[[["u"]],["option"]]],[11,"as_","","",0,[[["self"]],["u"]]],[11,"from_str_radix","","Parses `a +/- bi`; `ai +/- b`; `a`; or `bi` where `a` and `b` are of type `T`",0,[[["str"],["u32"]],["result"]]],[11,"zero","","",0,[[],["complex"]]],[11,"is_zero","","",0,[[["self"]],["bool"]]],[11,"one","","",0,[[],["complex"]]],[11,"is_one","","",0,[[["self"]],["bool"]]],[11,"inv","","",0,[[["self"]],["complex"]]]],"paths":[[3,"Complex"],[3,"ParseComplexError"]]};
searchIndex["num_integer"]={"doc":"Integer trait and functions.","items":[[3,"IterBinomial","num_integer","An iterator over binomial coefficients.",N,N],[5,"sqrt","","Returns the truncated principal square root of an integer -- see Roots::sqrt.",N,[[["t"]],["t"]]],[5,"cbrt","","Returns the truncated principal cube root of an integer -- see Roots::cbrt.",N,[[["t"]],["t"]]],[5,"nth_root","","Returns the truncated principal `n`th root of an integer -- see Roots::nth_root.",N,[[["t"],["u32"]],["t"]]],[5,"div_rem","","Simultaneous integer division and modulus",N,N],[5,"div_floor","","Floored integer division",N,[[["t"],["t"]],["t"]]],[5,"mod_floor","","Floored integer modulus",N,[[["t"],["t"]],["t"]]],[5,"div_mod_floor","","Simultaneous floored integer division and modulus",N,N],[5,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`. The result is always positive.",N,[[["t"],["t"]],["t"]]],[5,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",N,[[["t"],["t"]],["t"]]],[5,"binomial","","Calculate the binomial coefficient.",N,[[["t"],["t"]],["t"]]],[5,"multinomial","","Calculate the multinomial coefficient.",N,N],[8,"Roots","","Provides methods to compute an integer's square root, cube root, and arbitrary `n`th root.",N,N],[10,"nth_root","","Returns the truncated principal `n`th root of an integer -- `if x >= 0 { ⌊ⁿ√x⌋ } else { ⌈ⁿ√x⌉ }`",0,[[["self"],["u32"]],["self"]]],[11,"sqrt","","Returns the truncated principal square root of an integer -- `⌊√x⌋`",0,[[["self"]],["self"]]],[11,"cbrt","","Returns the truncated principal cube root of an integer -- `if x >= 0 { ⌊∛x⌋ } else { ⌈∛x⌉ }`",0,[[["self"]],["self"]]],[8,"Integer","","",N,N],[10,"div_floor","","Floored integer division.",1,[[["self"],["self"]],["self"]]],[10,"mod_floor","","Floored integer modulo, satisfying:",1,[[["self"],["self"]],["self"]]],[10,"gcd","","Greatest Common Divisor (GCD).",1,[[["self"],["self"]],["self"]]],[10,"lcm","","Lowest Common Multiple (LCM).",1,[[["self"],["self"]],["self"]]],[10,"divides","","Deprecated, use `is_multiple_of` instead.",1,[[["self"],["self"]],["bool"]]],[10,"is_multiple_of","","Returns `true` if `self` is a multiple of `other`.",1,[[["self"],["self"]],["bool"]]],[10,"is_even","","Returns `true` if the number is even.",1,[[["self"]],["bool"]]],[10,"is_odd","","Returns `true` if the number is odd.",1,[[["self"]],["bool"]]],[10,"div_rem","","Simultaneous truncated integer division and modulus. Returns `(quotient, remainder)`.",1,N],[11,"div_mod_floor","","Simultaneous floored integer division and modulus. Returns `(quotient, remainder)`.",1,N],[11,"new","","For a given n, iterate over all binomial coefficients binomial(n, k), for k=0...n.",2,[[["t"]],["iterbinomial"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"into_iter","","",2,[[["self"]],["i"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"next","","",2,[[["self"]],["option"]]],[11,"sqrt","","Returns the truncated principal square root of an integer -- `⌊√x⌋`",0,[[["self"]],["self"]]],[11,"cbrt","","Returns the truncated principal cube root of an integer -- `if x >= 0 { ⌊∛x⌋ } else { ⌈∛x⌉ }`",0,[[["self"]],["self"]]]],"paths":[[8,"Roots"],[8,"Integer"],[3,"IterBinomial"]]};
searchIndex["num_iter"]={"doc":"External iterators for generic mathematics","items":[[3,"Range","num_iter","An iterator over the range [start, stop)",N,N],[3,"RangeInclusive","","An iterator over the range [start, stop]",N,N],[3,"RangeStep","","An iterator over the range [start, stop) by `step`. It handles overflow by stopping.",N,N],[3,"RangeStepInclusive","","An iterator over the range [start, stop] by `step`. It handles overflow by stopping.",N,N],[5,"range","","Returns an iterator over the given range [start, stop) (that is, starting at start (inclusive), and ending at stop (exclusive)).",N,[[["a"],["a"]],["range"]]],[5,"range_inclusive","","Return an iterator over the range [start, stop]",N,[[["a"],["a"]],["rangeinclusive"]]],[5,"range_step","","Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.",N,[[["a"],["a"],["a"]],["rangestep"]]],[5,"range_step_inclusive","","Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.",N,[[["a"],["a"],["a"]],["rangestepinclusive"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"into_iter","","",0,[[["self"]],["i"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"into_iter","","",1,[[["self"]],["i"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"into_iter","","",2,[[["self"]],["i"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"into_iter","","",3,[[["self"]],["i"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"clone","","",0,[[["self"]],["range"]]],[11,"clone","","",1,[[["self"]],["rangeinclusive"]]],[11,"clone","","",2,[[["self"]],["rangestep"]]],[11,"clone","","",3,[[["self"]],["rangestepinclusive"]]],[11,"next","","",0,[[["self"]],["option"]]],[11,"size_hint","","",0,N],[11,"next","","",1,[[["self"]],["option"]]],[11,"size_hint","","",1,N],[11,"next","","",2,[[["self"]],["option"]]],[11,"next","","",3,[[["self"]],["option"]]],[11,"next_back","","",0,[[["self"]],["option"]]],[11,"next_back","","",1,[[["self"]],["option"]]]],"paths":[[3,"Range"],[3,"RangeInclusive"],[3,"RangeStep"],[3,"RangeStepInclusive"]]};
searchIndex["num_rational"]={"doc":"Rational numbers","items":[[3,"Ratio","num_rational","Represents the ratio between two numbers.",N,N],[3,"ParseRatioError","","",N,N],[6,"Rational","","Alias for a `Ratio` of machine-sized integers.",N,N],[6,"Rational32","","Alias for a `Ratio` of 32-bit-sized integers.",N,N],[6,"Rational64","","Alias for a `Ratio` of 64-bit-sized integers.",N,N],[6,"BigRational","","Alias for arbitrary precision rationals.",N,N],[11,"new","","Creates a new `Ratio`. Fails if `denom` is zero.",0,[[["t"],["t"]],["ratio"]]],[11,"from_integer","","Creates a `Ratio` representing the integer `t`.",0,[[["t"]],["ratio"]]],[11,"new_raw","","Creates a `Ratio` without checking for `denom == 0` or reducing.",0,[[["t"],["t"]],["ratio"]]],[11,"to_integer","","Converts to an integer, rounding towards zero.",0,[[["self"]],["t"]]],[11,"numer","","Gets an immutable reference to the numerator.",0,[[["self"]],["t"]]],[11,"denom","","Gets an immutable reference to the denominator.",0,[[["self"]],["t"]]],[11,"is_integer","","Returns true if the rational number is an integer (denominator is 1).",0,[[["self"]],["bool"]]],[11,"reduced","","Returns a reduced copy of self.",0,[[["self"]],["ratio"]]],[11,"recip","","Returns the reciprocal.",0,[[["self"]],["ratio"]]],[11,"floor","","Rounds towards minus infinity.",0,[[["self"]],["ratio"]]],[11,"ceil","","Rounds towards plus infinity.",0,[[["self"]],["ratio"]]],[11,"round","","Rounds to the nearest integer. Rounds half-way cases away from zero.",0,[[["self"]],["ratio"]]],[11,"trunc","","Rounds towards zero.",0,[[["self"]],["ratio"]]],[11,"fract","","Returns the fractional part of a number, with division rounded towards zero.",0,[[["self"]],["ratio"]]],[11,"pow","","Raises the `Ratio` to the power of an exponent.",0,[[["self"],["i32"]],["ratio"]]],[11,"from_float","","Converts a float into a rational number.",0,[[["t"]],["option",["bigrational"]]]],[11,"approximate_float","","",0,[[["f"]],["option",["ratio"]]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"clone","","",0,[[["self"]],["ratio"]]],[11,"clone","","",1,[[["self"]],["parseratioerror"]]],[11,"eq","","",0,[[["self"],["self"]],["bool"]]],[11,"eq","","",1,[[["self"],["parseratioerror"]],["bool"]]],[11,"ne","","",1,[[["self"],["parseratioerror"]],["bool"]]],[11,"cmp","","",0,[[["self"],["self"]],["ordering"]]],[11,"partial_cmp","","",0,[[["self"],["self"]],["option",["ordering"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","Renders as `numer/denom`. If denom=1, renders as numer.",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"from_str","","Parses `numer/denom` or just `numer`.",0,[[["str"]],["result",["ratio","parseratioerror"]]]],[11,"add","","",0,[[["self"],["ratio"]],["ratio"]]],[11,"add","","",0,[[["self"],["t"]],["ratio"]]],[11,"add","","",0,[[["self"],["ratio"]],["ratio"]]],[11,"add","","",0,[[["self"],["t"]],["ratio"]]],[11,"sub","","",0,[[["self"],["ratio"]],["ratio"]]],[11,"sub","","",0,[[["self"],["t"]],["ratio"]]],[11,"sub","","",0,[[["self"],["ratio"]],["ratio"]]],[11,"sub","","",0,[[["self"],["t"]],["ratio"]]],[11,"mul","","",0,[[["self"],["ratio"]],["ratio"]]],[11,"mul","","",0,[[["self"],["t"]],["ratio"]]],[11,"mul","","",0,[[["self"],["ratio"]],["ratio"]]],[11,"mul","","",0,[[["self"],["t"]],["ratio"]]],[11,"div","","",0,[[["self"],["ratio"]],["ratio"]]],[11,"div","","",0,[[["self"],["t"]],["ratio"]]],[11,"div","","",0,[[["self"],["ratio"]],["ratio"]]],[11,"div","","",0,[[["self"],["t"]],["ratio"]]],[11,"rem","","",0,[[["self"],["ratio"]],["ratio"]]],[11,"rem","","",0,[[["self"],["t"]],["ratio"]]],[11,"rem","","",0,[[["self"],["ratio"]],["ratio"]]],[11,"rem","","",0,[[["self"],["t"]],["ratio"]]],[11,"neg","","",0,[[["self"]],["ratio"]]],[11,"add_assign","","",0,[[["self"],["ratio"]]]],[11,"add_assign","","",0,[[["self"],["t"]]]],[11,"add_assign","","",0,[[["self"],["ratio"]]]],[11,"add_assign","","",0,[[["self"],["t"]]]],[11,"sub_assign","","",0,[[["self"],["ratio"]]]],[11,"sub_assign","","",0,[[["self"],["t"]]]],[11,"sub_assign","","",0,[[["self"],["ratio"]]]],[11,"sub_assign","","",0,[[["self"],["t"]]]],[11,"mul_assign","","",0,[[["self"],["ratio"]]]],[11,"mul_assign","","",0,[[["self"],["t"]]]],[11,"mul_assign","","",0,[[["self"],["ratio"]]]],[11,"mul_assign","","",0,[[["self"],["t"]]]],[11,"div_assign","","",0,[[["self"],["ratio"]]]],[11,"div_assign","","",0,[[["self"],["t"]]]],[11,"div_assign","","",0,[[["self"],["ratio"]]]],[11,"div_assign","","",0,[[["self"],["t"]]]],[11,"rem_assign","","",0,[[["self"],["ratio"]]]],[11,"rem_assign","","",0,[[["self"],["t"]]]],[11,"rem_assign","","",0,[[["self"],["ratio"]]]],[11,"rem_assign","","",0,[[["self"],["t"]]]],[11,"hash","","",0,[[["self"],["h"]]]],[11,"sum","","",0,[[["i"]],["self"]]],[11,"sum","","",0,[[["i"]],["self"]]],[11,"product","","",0,[[["i"]],["self"]]],[11,"product","","",0,[[["i"]],["self"]]],[11,"from","","",0,[[["t"]],["ratio"]]],[11,"from","","",0,N],[11,"into","","",0,N],[11,"pow","","",0,[[["self"],["i8"]],["ratio"]]],[11,"pow","","",0,[[["self"],["i8"]],["ratio"]]],[11,"pow","","",0,[[["self"],["i16"]],["ratio"]]],[11,"pow","","",0,[[["self"],["i16"]],["ratio"]]],[11,"pow","","",0,[[["self"],["i32"]],["ratio"]]],[11,"pow","","",0,[[["self"],["i32"]],["ratio"]]],[11,"pow","","",0,[[["self"],["i64"]],["ratio"]]],[11,"pow","","",0,[[["self"],["i64"]],["ratio"]]],[11,"pow","","",0,[[["self"],["isize"]],["ratio"]]],[11,"pow","","",0,[[["self"],["isize"]],["ratio"]]],[11,"pow","","",0,[[["self"],["u8"]],["ratio"]]],[11,"pow","","",0,[[["self"],["u8"]],["ratio"]]],[11,"pow","","",0,[[["self"],["u16"]],["ratio"]]],[11,"pow","","",0,[[["self"],["u16"]],["ratio"]]],[11,"pow","","",0,[[["self"],["u32"]],["ratio"]]],[11,"pow","","",0,[[["self"],["u32"]],["ratio"]]],[11,"pow","","",0,[[["self"],["u64"]],["ratio"]]],[11,"pow","","",0,[[["self"],["u64"]],["ratio"]]],[11,"pow","","",0,[[["self"],["usize"]],["ratio"]]],[11,"pow","","",0,[[["self"],["usize"]],["ratio"]]],[11,"checked_mul","","",0,[[["self"],["ratio"]],["option",["ratio"]]]],[11,"checked_div","","",0,[[["self"],["ratio"]],["option",["ratio"]]]],[11,"zero","","",0,[[],["ratio"]]],[11,"is_zero","","",0,[[["self"]],["bool"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_i128","","",0,[[["i128"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]],[11,"from_u128","","",0,[[["u128"]],["option"]]],[11,"from_f32","","",0,[[["f32"]],["option"]]],[11,"from_f64","","",0,[[["f64"]],["option"]]],[11,"checked_add","","",0,[[["self"],["ratio"]],["option",["ratio"]]]],[11,"abs","","",0,[[["self"]],["ratio"]]],[11,"abs_sub","","",0,[[["self"],["ratio"]],["ratio"]]],[11,"signum","","",0,[[["self"]],["ratio"]]],[11,"is_positive","","",0,[[["self"]],["bool"]]],[11,"is_negative","","",0,[[["self"]],["bool"]]],[11,"from_str_radix","","Parses `numer/denom` where the numbers are in base `radix`.",0,[[["str"],["u32"]],["result",["ratio","parseratioerror"]]]],[11,"one","","",0,[[],["ratio"]]],[11,"is_one","","",0,[[["self"]],["bool"]]],[11,"checked_sub","","",0,[[["self"],["ratio"]],["option",["ratio"]]]],[11,"inv","","",0,[[["self"]],["ratio"]]],[11,"description","","",1,[[["self"]],["str"]]]],"paths":[[3,"Ratio"],[3,"ParseRatioError"]]};
searchIndex["num_traits"]={"doc":"Numeric traits for generic mathematics","items":[[3,"ParseFloatError","num_traits","",N,N],[12,"kind","","",0,N],[4,"FloatErrorKind","","",N,N],[13,"Empty","","",1,N],[13,"Invalid","","",1,N],[5,"clamp","","A value bounded by a minimum and a maximum",N,[[["t"],["t"],["t"]],["t"]]],[0,"bounds","","",N,N],[8,"Bounded","num_traits::bounds","Numbers which have upper and lower bounds",N,N],[10,"min_value","","returns the smallest finite number this type can represent",2,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",2,[[],["self"]]],[0,"cast","num_traits","",N,N],[5,"cast","num_traits::cast","Cast from one machine scalar to another.",N,[[["t"]],["option"]]],[8,"ToPrimitive","","A generic trait for converting a value to a number.",N,N],[11,"to_isize","","Converts the value of `self` to an `isize`.",3,[[["self"]],["option",["isize"]]]],[11,"to_i8","","Converts the value of `self` to an `i8`.",3,[[["self"]],["option",["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`.",3,[[["self"]],["option",["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`.",3,[[["self"]],["option",["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`.",3,[[["self"]],["option",["i64"]]]],[11,"to_i128","","Converts the value of `self` to an `i128`.",3,[[["self"]],["option",["i128"]]]],[11,"to_usize","","Converts the value of `self` to a `usize`.",3,[[["self"]],["option",["usize"]]]],[11,"to_u8","","Converts the value of `self` to an `u8`.",3,[[["self"]],["option",["u8"]]]],[11,"to_u16","","Converts the value of `self` to an `u16`.",3,[[["self"]],["option",["u16"]]]],[11,"to_u32","","Converts the value of `self` to an `u32`.",3,[[["self"]],["option",["u32"]]]],[10,"to_u64","","Converts the value of `self` to an `u64`.",3,[[["self"]],["option",["u64"]]]],[11,"to_u128","","Converts the value of `self` to an `u128`.",3,[[["self"]],["option",["u128"]]]],[11,"to_f32","","Converts the value of `self` to an `f32`.",3,[[["self"]],["option",["f32"]]]],[11,"to_f64","","Converts the value of `self` to an `f64`.",3,[[["self"]],["option",["f64"]]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",N,N],[11,"from_isize","","Convert an `isize` to return an optional value of this type. If the value cannot be represented by this value, then `None` is returned.",4,[[["isize"]],["option"]]],[11,"from_i8","","Convert an `i8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["i8"]],["option"]]],[11,"from_i16","","Convert an `i16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["i16"]],["option"]]],[11,"from_i32","","Convert an `i32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["i32"]],["option"]]],[10,"from_i64","","Convert an `i64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["i64"]],["option"]]],[11,"from_i128","","Convert an `i128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["i128"]],["option"]]],[11,"from_usize","","Convert a `usize` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["usize"]],["option"]]],[11,"from_u8","","Convert an `u8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["u8"]],["option"]]],[11,"from_u16","","Convert an `u16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["u16"]],["option"]]],[11,"from_u32","","Convert an `u32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["u32"]],["option"]]],[10,"from_u64","","Convert an `u64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["u64"]],["option"]]],[11,"from_u128","","Convert an `u128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["u128"]],["option"]]],[11,"from_f32","","Convert a `f32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["f32"]],["option"]]],[11,"from_f64","","Convert a `f64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",4,[[["f64"]],["option"]]],[8,"NumCast","","An interface for casting between machine scalars.",N,N],[10,"from","","Creates a number from another value that can be converted into a primitive via the `ToPrimitive` trait.",5,[[["t"]],["option"]]],[8,"AsPrimitive","","A generic interface for casting between machine scalars with the `as` operator, which admits narrowing and precision loss. Implementers of this trait AsPrimitive should behave like a primitive numeric type (e.g. a newtype around another primitive), and the intended conversion must never fail.",N,N],[10,"as_","","Convert a value to another, using the `as` operator.",6,[[["self"]],["t"]]],[0,"float","num_traits","",N,N],[8,"FloatCore","num_traits::float","Generic trait for floating point numbers that works with `no_std`.",N,N],[10,"infinity","","Returns positive infinity.",7,[[],["self"]]],[10,"neg_infinity","","Returns negative infinity.",7,[[],["self"]]],[10,"nan","","Returns NaN.",7,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",7,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can represent.",7,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",7,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",7,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can represent.",7,[[],["self"]]],[11,"is_nan","","Returns `true` if the number is NaN.",7,[[["self"]],["bool"]]],[11,"is_infinite","","Returns `true` if the number is infinite.",7,[[["self"]],["bool"]]],[11,"is_finite","","Returns `true` if the number is neither infinite or NaN.",7,[[["self"]],["bool"]]],[11,"is_normal","","Returns `true` if the number is neither zero, infinite, subnormal or NaN.",7,[[["self"]],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.",7,[[["self"]],["fpcategory"]]],[11,"floor","","Returns the largest integer less than or equal to a number.",7,[[["self"]],["self"]]],[11,"ceil","","Returns the smallest integer greater than or equal to a number.",7,[[["self"]],["self"]]],[11,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",7,[[["self"]],["self"]]],[11,"trunc","","Return the integer part of a number.",7,[[["self"]],["self"]]],[11,"fract","","Returns the fractional part of a number.",7,[[["self"]],["self"]]],[11,"abs","","Computes the absolute value of `self`. Returns `FloatCore::nan()` if the number is `FloatCore::nan()`.",7,[[["self"]],["self"]]],[11,"signum","","Returns a number that represents the sign of `self`.",7,[[["self"]],["self"]]],[11,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0` and `FloatCore::infinity()`, and since Rust 1.20 also `FloatCore::nan()`.",7,[[["self"]],["bool"]]],[11,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0` and `FloatCore::neg_infinity()`, and since Rust 1.20 also `-FloatCore::nan()`.",7,[[["self"]],["bool"]]],[11,"min","","Returns the minimum of the two numbers.",7,[[["self"],["self"]],["self"]]],[11,"max","","Returns the maximum of the two numbers.",7,[[["self"],["self"]],["self"]]],[11,"recip","","Returns the reciprocal (multiplicative inverse) of the number.",7,[[["self"]],["self"]]],[11,"powi","","Raise a number to an integer power.",7,[[["self"],["i32"]],["self"]]],[10,"to_degrees","","Converts to degrees, assuming the number is in radians.",7,[[["self"]],["self"]]],[10,"to_radians","","Converts to radians, assuming the number is in degrees.",7,[[["self"]],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively. The original number can be recovered by `sign * mantissa * 2 ^ exponent`.",7,N],[8,"Float","","Generic trait for floating point numbers",N,N],[10,"nan","","Returns the `NaN` value.",8,[[],["self"]]],[10,"infinity","","Returns the infinite value.",8,[[],["self"]]],[10,"neg_infinity","","Returns the negative infinite value.",8,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",8,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can represent.",8,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",8,[[],["self"]]],[11,"epsilon","","Returns epsilon, a small positive value.",8,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can represent.",8,[[],["self"]]],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",8,[[["self"]],["bool"]]],[10,"is_infinite","","Returns `true` if this value is positive infinity or negative infinity and false otherwise.",8,[[["self"]],["bool"]]],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",8,[[["self"]],["bool"]]],[10,"is_normal","","Returns `true` if the number is neither zero, infinite, [subnormal][subnormal], or `NaN`.",8,[[["self"]],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.",8,[[["self"]],["fpcategory"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",8,[[["self"]],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",8,[[["self"]],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",8,[[["self"]],["self"]]],[10,"trunc","","Return the integer part of a number.",8,[[["self"]],["self"]]],[10,"fract","","Returns the fractional part of a number.",8,[[["self"]],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.",8,[[["self"]],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",8,[[["self"]],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and since Rust 1.20 also `Float::nan()`.",8,[[["self"]],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and since Rust 1.20 also `-Float::nan()`.",8,[[["self"]],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",8,[[["self"],["self"],["self"]],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",8,[[["self"]],["self"]]],[10,"powi","","Raise a number to an integer power.",8,[[["self"],["i32"]],["self"]]],[10,"powf","","Raise a number to a floating point power.",8,[[["self"],["self"]],["self"]]],[10,"sqrt","","Take the square root of a number.",8,[[["self"]],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",8,[[["self"]],["self"]]],[10,"exp2","","Returns `2^(self)`.",8,[[["self"]],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",8,[[["self"]],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",8,[[["self"],["self"]],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",8,[[["self"]],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",8,[[["self"]],["self"]]],[11,"to_degrees","","Converts radians to degrees.",8,[[["self"]],["self"]]],[11,"to_radians","","Converts degrees to radians.",8,[[["self"]],["self"]]],[10,"max","","Returns the maximum of the two numbers.",8,[[["self"],["self"]],["self"]]],[10,"min","","Returns the minimum of the two numbers.",8,[[["self"],["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",8,[[["self"],["self"]],["self"]]],[10,"cbrt","","Take the cubic root of a number.",8,[[["self"]],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",8,[[["self"],["self"]],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",8,[[["self"]],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",8,[[["self"]],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",8,[[["self"]],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",8,[[["self"]],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",8,[[["self"]],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];",8,[[["self"]],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",8,[[["self"],["self"]],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.",8,N],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",8,[[["self"]],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",8,[[["self"]],["self"]]],[10,"sinh","","Hyperbolic sine function.",8,[[["self"]],["self"]]],[10,"cosh","","Hyperbolic cosine function.",8,[[["self"]],["self"]]],[10,"tanh","","Hyperbolic tangent function.",8,[[["self"]],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",8,[[["self"]],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",8,[[["self"]],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",8,[[["self"]],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively. The original number can be recovered by `sign * mantissa * 2 ^ exponent`.",8,N],[8,"FloatConst","","",N,N],[10,"E","","Return Euler’s number.",9,[[],["self"]]],[10,"FRAC_1_PI","","Return `1.0 / π`.",9,[[],["self"]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",9,[[],["self"]]],[10,"FRAC_2_PI","","Return `2.0 / π`.",9,[[],["self"]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",9,[[],["self"]]],[10,"FRAC_PI_2","","Return `π / 2.0`.",9,[[],["self"]]],[10,"FRAC_PI_3","","Return `π / 3.0`.",9,[[],["self"]]],[10,"FRAC_PI_4","","Return `π / 4.0`.",9,[[],["self"]]],[10,"FRAC_PI_6","","Return `π / 6.0`.",9,[[],["self"]]],[10,"FRAC_PI_8","","Return `π / 8.0`.",9,[[],["self"]]],[10,"LN_10","","Return `ln(10.0)`.",9,[[],["self"]]],[10,"LN_2","","Return `ln(2.0)`.",9,[[],["self"]]],[10,"LOG10_E","","Return `log10(e)`.",9,[[],["self"]]],[10,"LOG2_E","","Return `log2(e)`.",9,[[],["self"]]],[10,"PI","","Return Archimedes’ constant.",9,[[],["self"]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",9,[[],["self"]]],[0,"identities","num_traits","",N,N],[5,"zero","num_traits::identities","Returns the additive identity, `0`.",N,[[],["t"]]],[5,"one","","Returns the multiplicative identity, `1`.",N,[[],["t"]]],[8,"Zero","","Defines an additive identity element for `Self`.",N,N],[10,"zero","","Returns the additive identity element of `Self`, `0`.",10,[[],["self"]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",10,[[["self"]],["bool"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",N,N],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",11,[[],["self"]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative identity.",11,[[["self"]],["bool"]]],[0,"int","num_traits","",N,N],[8,"PrimInt","num_traits::int","",N,N],[10,"count_ones","","Returns the number of ones in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of `self`.",12,[[["self"]],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount, `n`, wrapping the truncated bits to the end of the resulting integer.",12,[[["self"],["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount, `n`, wrapping the truncated bits to the beginning of the resulting integer.",12,[[["self"],["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",12,[[["self"],["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount, `n`, copying the \"sign bit\" in the most significant bits even for unsigned types.",12,[[["self"],["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",12,[[["self"],["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount, `n`, filling zeros in the most significant bits.",12,[[["self"],["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",12,[[["self"]],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's endianness.",12,[[["self"]],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's endianness.",12,[[["self"]],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",12,[[["self"]],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's endianness.",12,[[["self"]],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by squaring.",12,[[["self"],["u32"]],["self"]]],[0,"ops","num_traits","",N,N],[0,"checked","num_traits::ops","",N,N],[8,"CheckedAdd","num_traits::ops::checked","Performs addition that returns `None` instead of wrapping around on overflow.",N,N],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow happens, `None` is returned.",13,[[["self"],["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of wrapping around on underflow.",N,N],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.",14,[[["self"],["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of wrapping around on underflow or overflow.",N,N],[10,"checked_mul","","Multiplies two numbers, checking for underflow or overflow. If underflow or overflow happens, `None` is returned.",15,[[["self"],["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking on division by zero and instead of wrapping around on underflow and overflow.",N,N],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and division by zero. If any of that happens, `None` is returned.",16,[[["self"],["self"]],["option"]]],[8,"CheckedRem","","Performs an integral remainder that returns `None` instead of panicking on division by zero and instead of wrapping around on underflow and overflow.",N,N],[10,"checked_rem","","Finds the remainder of dividing two numbers, checking for underflow, overflow and division by zero. If any of that happens, `None` is returned.",17,[[["self"],["self"]],["option"]]],[8,"CheckedNeg","","Performs negation that returns `None` if the result can't be represented.",N,N],[10,"checked_neg","","Negates a number, returning `None` for results that can't be represented, like signed `MIN` values that can't be positive, or non-zero unsigned values that can't be negative.",18,[[["self"]],["option"]]],[8,"CheckedShl","","Performs a left shift that returns `None` on overflow.",N,N],[10,"checked_shl","","Shifts a number to the left, checking for overflow. If overflow happens, `None` is returned.",19,[[["self"],["u32"]],["option"]]],[8,"CheckedShr","","Performs a right shift that returns `None` on overflow.",N,N],[10,"checked_shr","","Shifts a number to the left, checking for overflow. If overflow happens, `None` is returned.",20,[[["self"],["u32"]],["option"]]],[0,"inv","num_traits::ops","",N,N],[8,"Inv","num_traits::ops::inv","Unary operator for retrieving the multiplicative inverse, or reciprocal, of a value.",N,N],[16,"Output","","The result after applying the operator.",21,N],[10,"inv","","Returns the multiplicative inverse of `self`.",21,N],[0,"mul_add","num_traits::ops","",N,N],[8,"MulAdd","num_traits::ops::mul_add","Fused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",N,N],[16,"Output","","The resulting type after applying the fused multiply-add.",22,N],[10,"mul_add","","Performs the fused multiply-add operation.",22,N],[8,"MulAddAssign","","The fused multiply-add assignment operation.",N,N],[10,"mul_add_assign","","Performs the fused multiply-add operation.",23,[[["self"],["a"],["b"]]]],[0,"saturating","num_traits::ops","",N,N],[8,"Saturating","num_traits::ops::saturating","Saturating math operations",N,N],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at the numeric bounds instead of overflowing.",24,[[["self"],["self"]],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating at the numeric bounds instead of overflowing.",24,[[["self"],["self"]],["self"]]],[0,"wrapping","num_traits::ops","",N,N],[8,"WrappingAdd","num_traits::ops::wrapping","Performs addition that wraps around on overflow.",N,N],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`, wrapping around at the boundary of the type.",25,[[["self"],["self"]],["self"]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",N,N],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`, wrapping around at the boundary of the type.",26,[[["self"],["self"]],["self"]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",N,N],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self * other`, wrapping around at the boundary of the type.",27,[[["self"],["self"]],["self"]]],[8,"WrappingShl","","Performs a left shift that does not panic.",N,N],[10,"wrapping_shl","","Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes any high order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.",28,[[["self"],["u32"]],["self"]]],[8,"WrappingShr","","Performs a right shift that does not panic.",N,N],[10,"wrapping_shr","","Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask` removes any high order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.",29,[[["self"],["u32"]],["self"]]],[0,"pow","num_traits","",N,N],[5,"pow","num_traits::pow","Raises a value to the power of exp, using exponentiation by squaring.",N,[[["t"],["usize"]],["t"]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an overflow occurred.",N,[[["t"],["usize"]],["option"]]],[8,"Pow","","Binary operator for raising a value to a power.",N,N],[16,"Output","","The result after applying the operator.",30,N],[10,"pow","","Returns `self` to the power `rhs`.",30,N],[0,"real","num_traits","",N,N],[8,"Real","num_traits::real","A trait for real number types that do not necessarily have floating-point-specific characteristics such as NaN and infinity.",N,N],[10,"min_value","","Returns the smallest finite value that this type can represent.",31,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",31,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",31,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can represent.",31,[[],["self"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",31,[[["self"]],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",31,[[["self"]],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",31,[[["self"]],["self"]]],[10,"trunc","","Return the integer part of a number.",31,[[["self"]],["self"]]],[10,"fract","","Returns the fractional part of a number.",31,[[["self"]],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.",31,[[["self"]],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",31,[[["self"]],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and with newer versions of Rust `f64::NAN`.",31,[[["self"]],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and with newer versions of Rust `-f64::NAN`.",31,[[["self"]],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",31,[[["self"],["self"],["self"]],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",31,[[["self"]],["self"]]],[10,"powi","","Raise a number to an integer power.",31,[[["self"],["i32"]],["self"]]],[10,"powf","","Raise a number to a real number power.",31,[[["self"],["self"]],["self"]]],[10,"sqrt","","Take the square root of a number.",31,[[["self"]],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",31,[[["self"]],["self"]]],[10,"exp2","","Returns `2^(self)`.",31,[[["self"]],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",31,[[["self"]],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",31,[[["self"],["self"]],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",31,[[["self"]],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",31,[[["self"]],["self"]]],[10,"to_degrees","","Converts radians to degrees.",31,[[["self"]],["self"]]],[10,"to_radians","","Converts degrees to radians.",31,[[["self"]],["self"]]],[10,"max","","Returns the maximum of the two numbers.",31,[[["self"],["self"]],["self"]]],[10,"min","","Returns the minimum of the two numbers.",31,[[["self"],["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",31,[[["self"],["self"]],["self"]]],[10,"cbrt","","Take the cubic root of a number.",31,[[["self"]],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",31,[[["self"],["self"]],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",31,[[["self"]],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",31,[[["self"]],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",31,[[["self"]],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",31,[[["self"]],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",31,[[["self"]],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];",31,[[["self"]],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",31,[[["self"],["self"]],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.",31,N],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",31,[[["self"]],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",31,[[["self"]],["self"]]],[10,"sinh","","Hyperbolic sine function.",31,[[["self"]],["self"]]],[10,"cosh","","Hyperbolic cosine function.",31,[[["self"]],["self"]]],[10,"tanh","","Hyperbolic tangent function.",31,[[["self"]],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",31,[[["self"]],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",31,[[["self"]],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",31,[[["self"]],["self"]]],[0,"sign","num_traits","",N,N],[5,"abs","num_traits::sign","Computes the absolute value.",N,[[["t"]],["t"]]],[5,"abs_sub","","The positive difference of two numbers.",N,[[["t"],["t"]],["t"]]],[5,"signum","","Returns the sign of the number.",N,[[["t"]],["t"]]],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can be negative).",N,N],[10,"abs","","Computes the absolute value.",32,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",32,[[["self"],["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",32,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",32,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",32,[[["self"]],["bool"]]],[8,"Unsigned","","A trait for values which cannot be negative",N,N],[8,"Num","num_traits","The base trait for numeric types, covering `0` and `1` values, comparisons, basic numeric operations, and string conversion.",N,N],[16,"FromStrRadixErr","","",33,N],[10,"from_str_radix","","Convert from a string and radix <= 36.",33,[[["str"],["u32"]],["result"]]],[8,"NumOps","","The trait for types implementing basic numeric operations",N,N],[8,"NumRef","","The trait for `Num` types which also implement numeric operations taking the second operand by reference.",N,N],[8,"RefNum","","The trait for references which implement numeric operations, taking the second operand either by value or by reference.",N,N],[8,"NumAssignOps","","The trait for types implementing numeric assignment operators (like `+=`).",N,N],[8,"NumAssign","","The trait for `Num` types which also implement assignment operators.",N,N],[8,"NumAssignRef","","The trait for `NumAssign` types which also implement assignment operations taking the second operand by reference.",N,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]]],"paths":[[3,"ParseFloatError"],[4,"FloatErrorKind"],[8,"Bounded"],[8,"ToPrimitive"],[8,"FromPrimitive"],[8,"NumCast"],[8,"AsPrimitive"],[8,"FloatCore"],[8,"Float"],[8,"FloatConst"],[8,"Zero"],[8,"One"],[8,"PrimInt"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"CheckedRem"],[8,"CheckedNeg"],[8,"CheckedShl"],[8,"CheckedShr"],[8,"Inv"],[8,"MulAdd"],[8,"MulAddAssign"],[8,"Saturating"],[8,"WrappingAdd"],[8,"WrappingSub"],[8,"WrappingMul"],[8,"WrappingShl"],[8,"WrappingShr"],[8,"Pow"],[8,"Real"],[8,"Signed"],[8,"Num"]]};
searchIndex["rust_rover"]={"doc":"Kata","items":[[3,"Position","rust_rover","A position in a 2d plane",N,N],[12,"0","","",0,N],[12,"1","","",0,N],[3,"Rover","","A rover with a particular position and direction in a plane",N,N],[4,"Direction","","The four cardinal directions",N,N],[13,"N","","",1,N],[13,"S","","",1,N],[13,"E","","",1,N],[13,"W","","",1,N],[4,"Instruction","","Instructions for the rover",N,N],[13,"Forward","","Advances forward one unit",2,N],[13,"RotateCW","","Rotates clockwise 90 degrees",2,N],[13,"RotateCCW","","Rotates counterclockwise 90 degrees",2,N],[11,"rotate_cw","","Rotate clockwise",1,[[["self"]],["direction"]]],[11,"rotate_ccw","","Rotate counterclockwise",1,[[["self"]],["direction"]]],[11,"new","","Create a new rover",3,[[["position"],["direction"]],["rover"]]],[11,"execute","","Execute an instruction",3,N],[11,"execute_many","","Execute many instructions",3,[[["self"],["i"]],["rover"]]],[11,"from_string","","Parse a string into a list of instructions",2,[[["s"]],["result",["vec","char"]]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"eq","","",1,[[["self"],["direction"]],["bool"]]],[11,"eq","","",0,[[["self"],["position"]],["bool"]]],[11,"ne","","",0,[[["self"],["position"]],["bool"]]],[11,"eq","","",3,[[["self"],["rover"]],["bool"]]],[11,"ne","","",3,[[["self"],["rover"]],["bool"]]],[11,"eq","","",2,[[["self"],["instruction"]],["bool"]]],[11,"clone","","",1,[[["self"]],["direction"]]],[11,"clone","","",0,[[["self"]],["position"]]],[11,"clone","","",3,[[["self"]],["rover"]]],[11,"clone","","",2,[[["self"]],["instruction"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"try_from","","",2,[[["char"]],["result",["instruction","char"]]]],[11,"add","","",0,[[["self"],["position"]],["position"]]],[11,"add","","",0,[[["self"],["d"]],["position"]]],[11,"sub","","",0,[[["self"],["position"]],["position"]]],[11,"hash","","",1,N],[11,"hash","","",0,N],[11,"hash","","",3,N],[11,"hash","","",2,N]],"paths":[[3,"Position"],[4,"Direction"],[4,"Instruction"],[3,"Rover"]]};
initSearch(searchIndex);
